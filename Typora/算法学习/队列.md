switch() 不能判断字符串，1.可以使用枚举的方式，2.使用strcmp函数对比

循环队列实现，核心就是用cnt记录当前个数





核心 1.底层是一个数组，可以使用vector也可以直接new， 如果是new的就需要一个capcity记录容量 2.**使用一个cnt来记录当前的数量** 3. 打印循环数组，即打印cnt个数， 用一个k来辅助，如果k==capcity ，则令k为0 

~~~c++
#include <bits/stdc++.h>
using namespace std;
int flag = 0;
class Queue {
    public:
    Queue(int n) : arr(new int[n]), head(0), tail(0), capcity(n), cnt(0) {}
    void push(int val) {
        if(full()) {
            cout << "队列满了 " << endl;
            return ;
        }
        tail = tail % 10;
        arr[tail] = val; 
        tail ++;
        cnt ++;
        
    }
    int pop() {
        if(empty()) {
            cout << "队列为空" << endl;
            return 0;
        }
        head %= 10;
        cnt --;
        return arr[head++];
    }
    bool full() {
        if(cnt == capcity) {
            return true;
        }
        return false;
    }
    bool empty() {
        if(cnt == 0) {
            return true;
        }
        return false;
    }
    int front(){ 
        return arr[head];
    }
    int Size() {
        return cnt;
    }
    void out() {
        
        for(int i = 0, k = head; i < cnt; i ++ ) {
            cout << arr[k] << " ";
            k ++;
            if(k == capcity) k = 0;
        } 
        
        cout << endl;
    }
    int head;
    int tail;
    int *arr;
    int capcity;
    int cnt;
};
int main() {
    Queue mq(10);
    string op;
    int val;
    
    while(cin >> op >> val) {
       if(op == "push") {
            mq.push(val);
            mq.out();
       }
       if(op == "front") {
            cout << mq.front() << endl;
            mq.out();
       }
       if(op == "size") {
            cout << mq.Size() << endl;
            mq.out();
       }
       if(op == "pop") {
            cout << mq.pop() << endl;
            mq.out();
       }
    }
    return 0;
}
~~~

