### 问 ：点击url发生的事情：
解析url，得到web服务器名称和文件名， 生成http请求消息(延展get， post方法)，DNS解析域名地址(拓展迭代法和递归法)，arp协议细讲

### 问：静态对象的用处，或者 单例模式的好处()

1.先介绍静态对象的位置，生命周期，不同文件没有命名冲突，extern无法访问

2.延展pthread_create,  必须使用静态函数原因，因为非静态函数有this指针，参数不一致，如果是全局函数，则破坏了类的封装性(谈到封装性可以扯c++中的**友元**)。 既然必须是静态函数，那么怎么访问类中的非静态成员呢，也就是pthread_create的第四个参数如何设置，有两种方式，**第一种**是传入一个pthis指针(这个pthis是一个静态指针，在对象构造函数初始化的时候设置pthis = this，**这也就提供了一种访问不同文件的变量的方法**)，或者直接传nullptr(使用单例方式的方式得到全局访问点)，有点像MFC中获取主窗口的方法，但如果是多个实例对象，这种方式就不可行了， **第二种**方式就是建立一个静态hash表，类中有一个静态成员m_sid  和一个普通成员 m_id 以及这个静态hash表，每个对象维护自己的m_id(构造函数初始化的时候，**值为当前静态hash表元素的个数+1**，所以我们是可以知道m_id的值的，可以给它记录一下), 第四个参数每次传入一个需要的对象的m_id 赋值给m_sid,就能通过这个静态hash表找到对应的this指针对象。为什么这里用静态的m_sid, 其实你用全局变量也可以，但还是那句话，破坏了封装性

3.static(因为没有this指针)和const(构造函数需要修改成员值，但const表示不能修改，并且const成员必须用初始化参数列表的方式来初始化，不能在构造函数中赋值)都不可以用来修饰构造函数或者析构函数

4.扯空指针对象可以调用普通函数，必须要有对象才有虚表，所以不能把构造函数弄成虚函数，通过虚表访问虚函数, 同一个类的所有对象的虚表都是一样的。vs打印c++类的分布查看虚表结构，多继承的虚表不止一个(前提是基类有虚函数)
基类和子类各自有不同的虚表虚表地址，**如果是基类指针指向子类对象，那么这时使用的是子类的虚表**。如果子类中没有虚函数， 尽管也是有独立的虚表，但子类的虚函数表里面的函数指针和父类是一样的

介绍一下隐藏的条件，
1.如果子类与父类函数名相同，但参数不同，无论子类是否有virtual都构成隐藏，这个过程也更加印证了一点，比如父类是虚函数，子类同名不同参，尽管它们都不是一个维度的，因为一个是虚函数，一个是非虚函数，但同样不变的原理就是都是先在子类作用域找是否有同名函数，没有再去父类，如果有就不管父类有没有了，只有显式加上作用域一种方法才可调用。(子类指针指向子类对象的情况)

 2. 如果子类与父类函数名相同，并且参数也相同，那么父类没有virtual修饰的时候构成隐藏。

5.介绍一下如何证明函数被隐藏了，对于调用问题严格区分虚(虚表)和非虚(静态联合)的情况就明白了，而对于隐藏的问题，其实是对函数名解析做了限制，如果出现同名，不管是否是虚函数，需要**先**在**子**类作用域找，如果找到了同名(不管是否与父类的同参，也不管是否是虚函数)，直接就不去父作用域找了，这也就是为什么出现了隐藏的原因(隐藏的时候无法调用父类的同名函数接口)，可以通过加上父类域名空间的方式访问被隐藏的函数， 为什么需要隐藏，想象一下如果在多继承的情况下，我们不这样做那到底该调用哪个父类的同名函数呢？这也就是c++的多继承**二义性**问题， 解决方案，1.加上父类域名 ，2.子类重写

对于父类的非虚函数而言，属于一种静态联编，这是一种**编译时**的多态性，又被称为静态多态(函数重载和运算符重载)，所以虽然基类指针指向了派生类，但由于绑定是在编译阶段就确定好了的，所以无论指向什么类型的对象，始终调用的都是基类中的方法，当然这只是说的非虚函数；
而对于虚函数，也就是实现动态多态的关键(3个必须，1.虚函数，2.继承，3.父类指针指向子类)， 因为这种情况下，我们的父类指针是用的子类的虚函数表，如果是正常的子类发生了重写，那么我们自然就能调用到子类实现的重写方法，但如果是隐藏，那么我们就应该还能调用到父类的这个方法，结果证明是可行的(比如父类是 virtual void test(), 而子类是void test(int a), 此时构成隐藏的条件)， 还需要特别注意一点，**父类指针不能访问子类对象定义的新成员**(不管是否是虚函数，或者普通成员)， 这也就说明了尽管我们使用的是子类的虚函数表，但我们仍然不能访问子类新定义的虚函数。

对于多态这一块，分析一下子类指针指向父类对象的情况。

5.单例模式先介绍什么是单例模式？ 保证任何情况下都只有一个实例，就像上边说的因为如果是static修饰就可以在不同文件中出现多个实例对象， 所以这个static 单例对象不能是全局的，为了保证它不是全局的，必须给类的**构造函数设置为私有的**，此时只剩下一种方式能调用类中方法，那么就是静态函数的方法，但static函数只能访问static对象，所以必须要在类中定义一个static对象这就是单例模式唯一实例必须设置为静态的原因。
1.介绍懒汉饿汉， 2.doublecheck加锁细节，3.如果是指针对象，必须要加一个静态函数进行资源释放(这也就是为什么shared_ptr存在循环引用的问题，因为类对象在析构的时候，不会管类的成员指针的释放，所以计数就不为0，也就无法释放了)

6.静态对象分为两大种， 一种是在类中的， 一种是不在类中的

**如果是类中的**，又有两种，一种是类的静态成员变量(不管是否是指针对象都是一样的)，另一种是类成员函数中的局部静态变量， 它们二者相同的地方是，当在类中写出这行代码， **都只是声明**的效果，并没有定义(也就是说没有分配具体的内存给它们，变量也是占内存的)， 而对于类的静态成员变量必须在类外第一时间就进行定义(也就是我们所说的初始化)， 不管你是否为它赋予具体的值，也不管这个变量是否是指针变量， 只有在类外定义的时候才为它分配内存空间(指针也是如此，这里说的不是new， 而就是说的这个指针对象)， 而对于类成员函数中的静态变量，又要**细细讨论**，如果**这个变量是一个普通类型比如int**，不管你是否初始化它， 都只有在第一次调用到它的时候才会为它分配变量的内存空间，这也就是它和静态成员变量的区别，分配内存的时机不同，也就是定义的时机不同， 在没有调用到它之前，它只是进行了声明，不占用内存大小， 而如果**这个变量是一个类的类型**，假设在主函数中，你定义了一个类的对象，通过这个类的对象调用包含这个局部静态变量(这里说的是类的类型变量的情况而不是int)**的函数**，那么你会发现这时其实是为这个对象分配了空间的(放在.bss段,因为并没有调用构造函数，我理解的原因可能是编译器认为类可能很大，所以当你代码中明显调用到的时候提前预分配空间)，但不变的核心还是，这个时候没有调用这个局部静态变量(类的类型）的构造函数。 如果不在主函数中调用包含这个局部静态变量的函数， 那么和int类型的局部静态函数的情况一样

这两种类型(int或者类的类型)的相同之处就是，当你第一次调用到它的时候，下一次再次进入这个函数，**不会**重新生成一个静态对象，而是就一直用第一次定义(也就是我们第一次进入初始化)的那个对象。

如果是非类中的，同样又是两种，一种是全局的静态变量， 那么当你写出这行代码的时候，它其实既包含了声明也包含了定义，是会为它直接分配内存的(它和普通的全局变量一样，在声明的时候如果你不自己赋值，**系统会默认帮你初始化(定义)为0** )， 而如果是函数中的局部静态变量，这里需要特别注意，和在类中的情况不太一样，不管你是一个int类型还是一个类的类型， 它**都**会给这个局部静态变量分配空间，比如是一个类的类型的对象，虽然会为它分配空间(放在.bss段,因为并没有调用构造函数)，但是不会调用它的构造函数， 如果是int类型，你初始化它了，它就放在.data段，你不初始化它，它就放在.bss段，**对于类的类型对象，并且是局部静态变量的时候，在类中与不在类中，它们的相同之处就是都是第一次调用到的时候，才会对这个对象进行构造**。

它们不管是哪种情况都遵循一样的原则， 即初始化为0或者未初始化则在.bss， 反之在.data段，这里提一点关于extern 的变量都是声明，因为它是引用的别的文件的变量，所有文件中只有一次定义。

对于纯虚函数，多线程封装任务类，实现一个run，就用纯虚，因为不同的任务一定有自己的run函数。

父类指针指向子类对象，然后又把这个父类指针转为子类指针， 那么其实这样操作跟 子类指针 指向 子类对象是一个道理，所对应的函数调用情况也跟子类指针指向子类对象时一样。

## 问const

const成员函数虽然不能改普通对象的值，但可以修改静态对象的值

当类中的某个成员不想被const成员函数限制，可以加上关键字mutable，比如 mutable int a; 那么就算在const函数里，依然可以对它进行修改。

const修饰类的成员变量，表示成员常量， 不能被修改，并且只有两种初始化方式，要么直接 const int a = 5; 要么不赋初值，但必须使用初始化参数列表的方式初始化。

**类中的同名函数，一个加const一个不加可以存在**，但无法重载两个同名但不同类型的函数，比如 int test(); 和 void test() 不能同时存在，但 int test(); int test() const可以同时存在。

const对象只能调用const函数

非const对象调用优先调用非const函数

const函数里面只能调用const函数。非const函数可以调用const函数

const函数如果在类外定义，必须加上const修饰，而static变量或者函数就可以不用加static。

const*  和  *const 区别。

参数列表加const的好处，不加之前只能传入左值，加了const就可以传右值，还可以使用const_cast转换去掉const属性

constexpr 和 const区别

要知道const修饰的函数，只是不能更改类对象的值，但是是可以自己定义变量，并修改变量的，如果该函数的参数不是const类型，那么也是同样的可以对参数变量的值进行修改。

1.constexpr可以在编译时期就确定是否是一个常量，而const是在运行时才能知道

~~~c++
const int a = 3;
const int b = a; //常量没问题
int c = 1;
const int d = c; // 不是常量表达式， 但可以编译通过
constexpr int e = c; //就会报错，因为编译器能够检查出c不是常量
~~~



2.constexpr可以修饰构造函数，但是成员变量要用初始化参数列表的方式，而const不能修饰构造函数，constexpr修饰的构造函数可以对类成员进行修改。

3.

### 问：I/O多路复用

1.先解释I/O复用是什么意思

2.select，poll， epoll(ET(边沿触发)必须是非阻塞, LT(水平触发)) 

ET模式的服务器(listenfd同时监听epollin和epollout)， 当有客户端连接到来时，listenfd触发一次epollin，不会触发epollout， 服务器为这个连接注册消息(不管你是只注册epollout还是epollin一起注册)，**只会触发一次**epollout不会触发epollin。 当客户端发送消息来的时候，会同时触发epollin和epollout。

LT模式的服务器(listenfd同时监听epollin和epollout)， 当有客户端连接到来时，listenfd触发一次epollin，不会触发epollout，服务器为这个连接注册消息(不管你是只注册epollout还是epollin一起注册)，会**循环触发**epollout不会触发epollin。 当客户端发送消息来的时候，会同时触发epollin和epollout。

可以看到不管是ET还是LT模式的服务器，它们的listenfd都有一个相同的特点，不管这个listenfd是et还是lt模式，也不管它是否注册了epollout，它都只会触发epollin消息。 同时也该明白不管connect是否成功，我们都可以去第一次触发的epollout事件里面获取errno值来判断是否成功。

当有epollin消息的时候总是会有epollout，这不意味着有epollout的消息，它只是意味着一个消息被触发(套接字变得可读)，我得到了一个**新的状态**，只是表明一种状态更新(update)，那么就会假设此时的socket是可写的，并且不会带来什么危害， 实质上我们注册EPOLLET模式就是在告诉内核不要给我们发送重复的状态信息，我们会维护自己的状态标记。
 比如在ET模式下，不管发送消息是否发送完，或者接收消息是否接受完，整个都是相同的状态，不会发生状态的改变，所以内核不会重新通知我。

拓展：如果采用EPOLLET模式，并且**只**给新连接注册EPOLLOUT事件，那么只会在刚注册的时候触发一次EPOLLOUT， 之后永远不会触发EPOLLOUT事件。 可以充分的看出来ET模式下的EPOLLOUT是依赖于状态更新的。

LT： 可读就读，可写就写

ET：有读才读，有写才写 

3.多线程访问同一个fd问题， epoll_oneshot

4.阻塞和非阻塞区别，如果connect使用非阻塞的方式，怎么来判断是否成功，判断第一次write事件(因为connect无论成功与否都会触发write事件)，通过getsockopt来获取错误码，如果没有错误码则表明connect成功，反之使用重连机制重新连接

select：能监听1024个文件描述符(本质上是一个long类型的数组，大小为16)，监听三种事件(并且注册事件的时候只能一个一个注册)，轮询所有fd，并且每次select都需要重写注册事件，因为位图被打乱了。

![1676210361901](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1676210361901.png)

poll: 不限制描述符数量，可以监听多种事件(按位与的方式)，轮询所有fd，相当于高效的epoll:不限制描述符数量，可以监听多种事件(按位与的方式)，只处理发生的事件，底层是红黑树和双向链表。



5.扯统一事件源， epoll_wait最后一个参数，定时器设计

**6.同步IO， 异步IO模型：**与同步异步的区别， 分析适用场景，延展Reactor(write, read)，Proactor(aio_read, aio_write，这两个接口会告诉内核读写缓冲区的位置，全部操作由内核完成，直接向内核注册的是**读完成事件**， 而Reactor中注册的是**读事件**)

**7.惊群问题**：对于accept的惊群，内核2.6已经解决了， 对于epoll_wait的惊群问题，设置epoll事件中的EPOLLEXCLUSIVE模式，保证每次只唤醒一个epoll_wait, 和EPOLL_ONESHOT(保证事件只促发一次，防止多线程对同一个fd进行操作)有点类似，为什么只保证了accept，而epoll_wait让用户自己选择， 因为accept只针对listenfd，而epoll_wait还要监听各种fd。

区分一下两种不同的情况(这两种情况,目前linux内核都有处理的办法)。

1. 多个进程/线程使用同一个epfd然后调用epoll_wait     //memcached 多线程
2. 多个进程/线程有自己的epfd,然后监听同一个socket   //nginx  多进程

Redis 采用的是 单 Reactor 单进程的方式，Memcache 采用的是 多 Reactor 多线程的方式，Nginx 采用的是多 Reactor 多进程的方式

通过memcached网络模型和Nginx，引出我自己的进程池模型，所有进程都listen了listenfd(也就是继承了父进程的状态)， 但只有父进程把listenfd放到了epoll_wait中监听， 当收到listenfd信息后，父进程通过负载均衡以管道的	方式将命令发送给**子进程进行accept处理**（每个子进程都有自己独立的epfd)，而Nginx是主线程直接accept，然后把fd通过管道发送给特定的子线程，由子线程放到字节的epoll中(子线程不是同一个epfd，也就是多Reactor模型的意思)

```
对于nginx是先fork,再调用epoll_create,各进程独享自己的epfd。

Nginx 目前有几种方法解决惊群问题：
accept_mutex
如果开启了accept_mutex 锁，每个 worker 都会先去抢自旋锁，只有抢占成功了，才把 socket 加入到 epoll 中，accept 请求，然后释放锁。accept_mutex 锁也有负载均衡的作用(为了保证每个进程的任务量均衡，具体实现就是判断一个值是否足够大，如果是，就不去尝试获取锁，并且每次将这个值减一)。
为了减少单个进程长时间占据accept，
导致其他进程无法接受新连接，应该尽量减少accept锁的占据时间， nginx采用了 NGX_POST_EVENTS 标志位，如果获取到了锁，就把事件(accept事件，普通事件)放到两个队列中延迟处理，然后先去处理accept事件的那个队列，然后立即释放accept锁，再去另外一个普通事件的队列。

EPOLLEXCLUSIVE
EPOLLEXCLUSIVE 是 Linux 4.5+ 内核新添加的一个 epoll 的标识，Nginx 在 1.11.3 之后添加了 NGX_EXCLUSIVE_EVENT。EPOLLEXCLUSIVE 标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多个进程监听下的“惊群”问题。不过任一时候只能有一个工作线程调用 accept，限制了真正并行的吞吐量。

SO_REUSEPORT
SO_REUSEPORT 是惊群最好的解决方法，Nginx 在 1.9.1 中加入了这个选项，每个 worker 进程都有自己的 socket，这些 socket 都 bind 同一个端口。当新请求到来时，内核根据四元组信息进行负载均衡，非常高效。
```

这里需要注意，我写的**只有主进程**才会把listenfd放到监听队列中

 但内核3.9开始，给socket提供了SO_REUSERPORT特性，可以让不同的socket绑定在同一个端口上，那么我们可以让每个线程都有一个socket(绑定在同一个端口)，在accept的时候，内核会自动处理惊群问题。
可以这么理解，现在有多个socket(绑定在同一个端口上)， 当有连接信息过来的时候，内核负载均衡的选择其中一个，那么只有这个socket对应的epoll_wait才会触发，自然也就解决了epoll惊群问题，更不会有accept问题

EPOLLEXCLUSIVE模式和SO_REUSERPORT都能解决惊群，但SO_REUSERPORT使用的更多，性能更好

8.介绍epoll_event.data.中的指针对象的好处

### 问：hashmap

哪些重要属性：1.size已经存储的节点个数， 2.threshold 扩容阈值， 当hashmap的个数达到该值时，触发扩容， 3.loadfactor：负载因子，扩容阈值=容量 * 负载因子

考虑时间和空间的权衡，链表转红黑树的阈值是8(如果达到9，并且此时数组长度>=64会发生转化)， 红黑树转链表的阈值是6，如果都是8，很容易转来转去

扩容机制：比如数组大小是4，一个数据通过hash得到的值是6 (110)，那么取余后为2，此时若对数组扩容变为8， 则用刚才的6 & n-1 即 (110 & 111) 只用判断第一位相&后是否为1， 若是，则6在新的扩容数组的下标为原来的下标(2) + 原来的数组大小(4)  = 6；

缩容机制同理： 比如现在数组大小为8，当前索引位置为6(110), 需要缩容到4(100), 则将6 & 2^n (即是4) ，看第一位是否为1， 若是则新位置为原来的位置(6) - 缩容后的数组大小(4) = 2;

rehash方法，需要一个**指针**， 每次获取值的时候，先hash得到索引，判断这个索引大小是否比这个**指针**的位置大， 若是则在原来的hash数组中找， 反之去新数组找， 同时将原来的数组的**当前指针**位置数据更新到新数组中去，将**指针**往后移动一位，直至完全rehash

**拓展：**key-value存储原理，

redis中的字典结构， 字典结构包含的主要属性有，rehash指针， 迭代器，两个哈希表(每个hash表的主要属性包含，具体的table(数组)，总容量，已经使用的大小)，一般只使用第一个hash表，除非需要rehash的时候会使用两个，rehash完毕释放不要的那一个，把第一个hash表指向需要用的那一个(这也就是为什么一般只用第一个hash表)，扩容缩容一样的原理。

哈希冲突，开放地址，公共溢出区，拉链法， redis中采用的是拉链法，每个哈希位置都有一条链表，链表的元素类型为dictEntry(包括了key和value的值以及下一个节点的指针)， 比如现在key1和key4发生了冲突，那么在hash表的同一个位置上的这条链表上就有两个元素，一个是(key1, value1，它的next指针就指向key4), 另一个是(key4,value4), 

再谈字典中的迭代器， 它的作用其实就是遍历hash表，迭代器的主要字段包括，当前正在迭代的字典，正在迭代的hash表的号码(0或1)， 正在迭代的hash索引位置， 具体的这个hash节点的指针，以及是否是安全迭代器(如果安全可以对字典进行修改，反之不行)

拓展： hash聚集，链表法存在hash聚集问题， 开放地址法也只是将hash聚集延后了， 本质上解它们可以使用双重hash的方法，具有强随机性

## 问操作系统

回答虚拟地址如何变到物理地址(MMU)， 讲页表主要项，多级页表机制， DMA机制， TLB机制
延展，缺页异常情况如何处理， 扯free命令中的buffer/cache, 扯malloc分配机制

## 问构造函数

1.发生构造函数的情况 

2.类的对象初始化顺序(先构造函数的参数，再成员，最后构造函数里面的实现) 

3.移动构造和移动赋值的优势， 为什么不能用移动构造和移动赋值来代替拷贝构造和拷贝赋值(因为场景需求不同，有时候我们就需要有两份数据，就必须要拷贝构造函数) 。

4.为什么要把拷贝构造函数的参数设置为&(以防循环构造问题)，以及为什么需要设置为const(const能保证既能传递左值也能传递右值)
这里引申move失效问题(如果没有移动构造函数， 此时尽管是右值，但也是调用的拷贝构造函数)。

~~~c++
A a;
A b(move(a));  //move(a) 相当于一个右值了


如果没有移动构造函数，并且拷贝构造函数参数没有加上const， 则会报错，这也就是为什么一般拷贝构造函数也要加上const。
~~~

5.RVO优化情况(A a = getA()) 优化为去掉返回值，变成getA(&a)的方式。这里解释以下汇编的原理。

## 问mvcc

解释多版本(undolog链)，并发控制(快照，那四个变量的含义)， 延展etcd中的mvcc(在etcd2中最开始指只保留最新的key，不能保存历史记录，后来推出了窗洞窗口的使用，但无法面对大并发， 进而etcd3中使用b+树) ，

etcd2 和 etcd3 区别。使用 gRPC + protobuf 取代 http + json 通信，提高通信效率；gRPC 只需要一条连接；http 是每个请求建立一条连接；protobuf 加解密比 json 加解密速度得到数量级的提升；包体也更小

## 问inline区别

先用汇编回答函数调用的整个过程，x86只有8个寄存器，所以调用别的函数的时候需要先把主函数的信息记录下来，就需要记录在栈中，但栈在内存中，访问内存有一定的消耗，并且还有可能如果这个函数的地址没有在同一个页中，并且还没有建立对应的页表机制，可能出现缺页异常，那么消耗就更大了， 进入(call，)这个函数的时候还需要将这个函数所需要的**参数先压栈**(从后往前压栈，然后再把**当前的执行位置**压栈记录下来，方便恢复)， 当函数执行完之后，两个对栈操作的指针会指回原来的地方，所以其实内容上的值可能没有变，但它已经不属于我们了，下一次用到那块内存的时候直接就覆盖了，return操作其实就是把返回值压到一个指定寄存器中，再去找到ret返回主函数的地址，跳回主函数，然后再恢复刚才保存的上下文内容， 其实这个跟中断异常的情况也是一样的，都需要先保存上下文，然后去执行另外的东西，最后再恢复上下文。

用**寄存器来存储参数和结果**是最常使用的方法，对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器取到返回值；子程序从参数寄存器中取到参数，将返回值送入结果寄存器 ，根据资源来决定具体是哪种方式，这也就是为什么每个页都有一个标志位为禁止高速缓存位， 假如操作系统正在等待某个I/O设备对他发出的命令做出响应，保证硬件是不断从设备中读取数据而不是高速缓存的副本是很重要的

再说inline在编译的时候展开，会跟函数一样进行类型检查，而define在预处理就展开，不进行类型检查，inline应该注意什么(代码量太大)， 构造函数和析构函数不建议inline，因为它们内部还有一些其他的很多事情要做，比如分配对象要申请内存，做一些初始化操作或者回收操作， 减少入栈出栈，提高效率

对于inline，虚函数是可以设置为inline的， 只是如果是父类指针指向子类对象的时候不会展开， 而类的对象自己调用就会展开(因为这种调用行为是在编译时就能确定的)

## 问redis

介绍redis和mysql中事务的区别.

只要问到事务,就延展watch命令, watch命令监控键值对, 当exec执行事务的时候,会先比较键值对是否发生了改变, 如果没有改变则继续执行,反之回滚事务, 不管事务是否执行成功,我们都需要取消watch监控的键值,

**watch的原理是cas, 是一种乐观锁机制**,在拓展aba问题

## 问Http

用wireshark工具抓包测试

- get 请求的 URL 有长度限制这一点是不准确的,有限制是因为不同浏览器的输入框有限制,以及服务器的实现有限制,而本身的http协议是没有限制的，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。
- get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。
- get 请求在浏览器反复的 `回退/前进` 操作是无害的，而 post 操作会再次提交表单请求。
- get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。
- get使用url编码方式,而post支持的编码方式多.

扯http的无状态怎么解决,为什么我们每次登录浏览器都会自动帮我们输入密码,进而拓展cookie和session机制

**OKHttp的源码是这样写的**:Expect：100-continue，那么客户端先发送第一个包：请求头，并且阻塞读取服务端的回复。（2）然后服务端如果满足客户端的期望的话，会发送100continue，否则发送417.（3）客户端读取到服务器的状态行的响应码 如果是100 continue，那么客户端就得继续发送RequestBody，否则就结束请求。回到（1）这里，如果没有Expect的请求头，那么客户端不会先发送请求头的，会把请求头和RequestBody一起发送给服务器。

**如果当post是两个tcp包的情况**
post先去检测一下服务器是否能正常应答，然后再把data携带过去，如果应答不了，就没有了第二步数据传输。 就好像送快递的先打个电话给你看看你在不在家，在的话再送过去，以免不必要的资源浪费。

**get、post之外重要方法**
put:向指定资源位置上传其最新内容
delete:请求服务器删除URI所标识的资源
trace:回显服务器收到的请求，主要用于测试或诊断
option:可使服务器传回该资源所支持的所有http请求方法，可以测试服务器功能是否正常运作
head:和get一样都是向服务器发出指定资源的请求，不过它不回复资源的文本部分，它的好处在于，不必传输全部内容的情况下，就可以获取关于该资源的信息(元信息或元数据)

**http1.1优化**
1.避免发送http请求， 客户端缓存资源，若有并且未到期(服务器会给客户端一个大致的可能过期时间)，则直接客户端拿，若判断为到期，去服务器拿，服务器显示还可以继续用，返回304，就不需要再次传递相同的资源，收到304继续用客户端先前缓存的。

2.减少重定向次数，比如如果当时有一个**代理服务器**，直接让代理服务器做重定向的工作，就可以减少客户端http的请求次数了。

3.合并请求，比如请求9个小图标，可以合并为请求一个大图片上边包含了9个小图标，把9次请求合并为一次，**减少了重复的头部，减少了http请求次数**。 从9次共36K变化到了1次4K， 比如CSS技术就可以进行合并，再根据CSS数据把大图片切割成多张小图片。
但这样也会有一个问题，有一个小图片发生变化，客户端必须重新下载整个完整的大资源文件。

4.延迟发送请求，比如打开一个网页，只会获取当前能看到的信息， 当你往下滑动的时候，进一步获取信息，而不会一次获取全部信息。

5.http响应数据的压缩
无损：gzip，信息经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件，代码，或者可执行文件，比如换行或者空格符号，只是方便我们阅读，机器执行并不需要这些。
有损：压缩图片或者音频，解压后的数据与元数据有所不同但非常接近。
总之都是为了压缩响应资源，提高传输效率