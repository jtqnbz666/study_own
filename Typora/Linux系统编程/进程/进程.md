#   进程

## 1.进程的定义

 程序包含位于内存的多个组成部分，执行程序的过程将根据需要来访问这些内容，包括文本段（text segment）、数据段（data segments）、栈（stack）和堆（heap）。文本段中存放CPU所执行的命令，数据段存放进程操作的所有数据变量，栈存放自动变量和函数数据，堆存放动态内存分配情况数据。当进程被创建时，子进程收到父进程的数据副本，包括数据空间、堆、栈和进程描述符
————————————————

进程寻址空间0~4G  
*进程在用户态只能访问0~3G，只有进入内核态才能访问3G~4G  
*进程通过系统调用进入内核态
*每个进程虚拟空间的3G~4G部分是相同的  
*进程从用户态进入内核态不会引起CR3的改变但会引起堆栈的改变

​	可执行程序文件
​	运行中的程序
​	操作系统资源调度的基本单位
​			资源：内存 fd(文件描述符)  cpu时间片。。。
​	内存最小单位  bit   内存的最小管理单位  byte

## 2.进程的组成

- 数据：全局变量  静态变量(已初始化，未初始化)，只读变量(const修饰的)
- 代码：进程的源代码
- 堆栈：变量  手动内存分配(堆空间) 

## 3.进程的模式
​    用户模式：应用程序正在运行
   内核模式：调用系统调用  系统中断

## 4.进程的运行：
	### 4.1 手动运行
​		命令   执行可执行程序
​	### 4.2 调度
​		ps  -aue
​		top
​		nice renice  控制进程是否让步
​					进程的优先级
​		kill 
​		crontab
​		bg		

## 5.如何创建进程
### 5.1 system();//在程序中执行命令
​	**创建完后当前进程不再执行了(挂起)，等被创建进程结束后再继续运行**

## 代码演示system()

具体实现：gcc test.c -o t.exe
再 gcc jincheng.c  生成可执行文件a.out
最后./a.out即可

```C++
//jincheng.c文件名
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
int main()
{
	printf("大家好！我要开始睡觉了哦~\n");
	sleep(3);
	printf("我睡醒了！要上班了~\n");
	system("./t.exe");//需要执行的命令，这是另一个文件的可执行文件名
	sleep(5);
	printf("bye bye！！\n");
	return 0;
}
```

```c++
//test.c文件
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
int main()
{
	for(int i=0;i<10;i++)
	{
		printf("%d:%d\n",getpid(),i);
	}
	printf("被创建进程结束！\n等五秒试试！\n");
	return 0;
}
```



### 5.2 fork   vfork
​	创建子进程：当 前进程是父进程，被创建进程是子进程
​	**创建完之后父子进程同时执行**

​	拷贝方式来创建，fork函数创建子进程，子进程拷贝父进程的所有代码并且记录进程上下文(运行到啥时候了)

​	**父进程的fork()返回子进程ID，子进程返回0；**

fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有[进程空间](https://www.zhihu.com/search?q=进程空间&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A370705498})的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。

## 代码演示父子进程1：

~~~C++
//fork.c文件名
#include <stdio.h>
#include <unistd.h>

int main()
{
	printf("这是父进程，父进程ID：%d\n",getpid());
	sleep(2); 
	printf("创建子进程！\n");
	int n=58;
	int ret=fork();
	if(ret)
	{	
		printf("这是父进程:%d\n,    ret:%d\n",getpid(),ret);
		while(1)
			{
				printf("n:%d\n",n++);
				sleep(1);
			}
	}
	else
	{
		printf("这是子进程:%d\n,     ret:%d\n",getpid(),ret);
		while(1)
			{
				printf("m:%d\n",n+2);
				sleep(1);
			}
	}
}
~~~

## 代码演示父子进程2：

打印时间，学习一下linux下与时间相关的函数。
这里面加了一个好玩的，就是登陆账号密码判断是否正确。

~~~c++
//parentChild.c文件名
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
int main()
{
	//父进程滚动打随机数
	//子进程打印当前时间
	char userName[25]="student";
	char passWord[25]="123456";

	char user[25];
	char pass[25];
	while(1)
	{
		printf("请输入用户名：");
		scanf("%s",user);
		printf("请输入密码:");
		scanf("%s",pass);

		if(0==strcmp(user,userName)&&
			0==strcmp(pass,passWord))
		{
			printf("登陆成功！\n");
			break;
		}
		else
		{
			printf("登陆失败，请重新输入！\n");
			sleep(2);
			system("clear");
		}
	}


	if(fork())
	{
		//父进程
		//打印当前时间
		struct tm* pt;
		time_t tt;

		while(1)
		{
			tt=time(0);
		pt=localtime(&tt);
		printf("时间：%02d:%02d:%02d\n",
			pt->tm_hour,pt->tm_min,pt->tm_sec);
		sleep(1);
		}
	}
	else
	{
		//子进程
		//显示随机数
		srand(time(0));
		while(1)
		{
			printf("=============%07d===========\n",
				rand()%10000000);
				usleep(500000);
		}
	}

	return 0;
}
~~~



### 5.3 exec簇    
不是创建新进程，只是进程的替换

execl  execv  execle  execlp  execvp

**进程替换原理**：子进程往往要调用一种exec函数以执行另一个程序。**当进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动例程开始执行**。调用exec并不创建新进程,所以调用exec前后该进程的id并未改变.

**注意**：这里的替换原理就是将子进程中映射页表中映射数据段和代码段的的位置进行初始化，然后让**页表重新映射到要替换的程序的代码段和数据段**；更通俗易懂的就是在**页表上动手脚**，修改页表映射让其映射到新的程序；而不是在页表映射的那一块物理内存上动手脚；

![](C:\Users\ASUS\Pictures\博客图片\20200101215734398.png)

## 代码演示exec簇

~~~c++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

int main(int argc,char *argv[])
{
	pid_t pid=fork();
	if(pid==-1)
	{
		perror("fork error\n");
		exit(1);
	}
	else if(pid==0)//子进程
	{
		//execlp("ls","-l","-h",NULL);//错误写法
		//execlp("ls","ls","-l","-h",NULL);//正确写法
		
		//execl("/bin/ls","ls","-l",NULL);//若没有p就需要相对或绝对路径
		//execl("./a.out","a.out",NULL);//在NULL之前也可以给a.out加点参数
		execl("./a.out","a.out","2.txt","1.txt",NULL);

		perror("exec error");//如果上边的成功了就不会执行到这一步
		exit(1);
	}
	else if(pid>0)//父进程
	{
		sleep(1);
		printf("结束了哦！");
	}
	return 0;
}
~~~





## 6.进程的状态

   	运行时    睡眠	挂起	等待	死亡状态	僵尸	。。。

## 7.进程的结束
​		僵尸进程：父进程创建了子进程，父进程先于子进程结束，子进程资源没有被释放，就会变成僵尸进程，持续占用系统资源。

​		子进程结束前，会向父进程发送SIGCHILD信号，父进程收到消息后，回收子进程资源，然后父进程再结束，

​		父进程 	写一个		wait() 函数    等待子进程发送  SIGCHILD信号

## 代码演示wait()：

~~~c++
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
int main()
{
	
	if(fork())
	{
		printf("子进程被创建了！\n");
		wait(0);//需要在子进程被创建后再使用！作用是等待子进程结束回收资源
	}
	else
	{
		for(int i=0;i<5;i++)
		{
			print("子进程：%d\n",i);
			sleep(1);
		}
	}  

	printf("父进程结束！！\n");
}
~~~



​		waitpid() 函数，指定等某一个子进程发送信号。

## 8.守护进程
	### 8.1独立，记录其他进程的情况(记录操作系统  系统日志)
	### 8.2 如何查看当前系统上的守护进程  ps  axj
​		PXJID 为  -1 的是守护进程
​	### 8.3 如何创建守护进程
​			8.3.1守护进程的功能实现和其他进程一样
​			8.3.2如果希望把一个进程变成守护进程
​					8.3.2.1把它的父进程干掉
​					8.3.2.2摆脱终端控制(如ctrl+c结束进程这类)
​						关闭  0  1   2   文件描述符号
​						0  1  2 是终端   0  标准输入设备   1  标准输出设备  2   标准错误输出设备
​						重定向当前进程的IO操作到  /dev/null  黑洞设备
​					8.3.2.3 创建新的会话：
​							摆脱原有会话，进程组的控制

		### 8.4 守护进程创建编程模型
​				第一种： 
​						1.创建当前会话  setsid
​						2.改变当前工作目录  chdir
​						3.重设当前文件权限  umask
​						4.关闭文件     			close
​				第二种：
​						1.重设文件权限           umask
​						2.创建子进程			   fork
​						3.让父进程结束
​						4.创建新会话				setsid
​						5.防止子进程成为僵尸进程   	忽略掉SIGCHLD   SIGHUP信号
​						6.改变当前工作目录  	chdir
​						7.重定向文件描述符号    open  dup2(fd,0)   dup2(dup,1)

## 代码演示守护进程：

~~~C++
//shouhujincheng.c文件名
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>    
#include <sys/wait.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
int main()
{
	//1.重设文件权限           umask
	umask(0);
	//2.创建子进程			   fork
	int ret=fork();
	if(ret<0)printf("创建进程失败：%m"),exit(-1);
	if(ret>0)printf("父进程结束：%m\n"),exit(0);//3.让父进程结束
	if(0==ret)
	{
		printf("pid:%d\n",getpid());
	//4.创建新会话				setsid
	setsid();
	//5.防止子进程成为僵尸进程   	忽略掉SIGCHLD   SIGHUP信号
	signal(SIGCHLD,SIG_IGN);
	signal(SIGHUP,SIG_IGN);
	//6.改变当前工作目录  	chdir
	chdir("/");
	//7.重定向文件描述符号    open  dup2(fd,0)   dup2(fd,1)
	int fd=open("/dev/NULL",O_RDWR);
	dup2(fd,0);
	dup2(fd,1);
	}
	while(1)
	{
		sleep(1);//模拟守护进程工作
	}
	return 0;
}
~~~



## 9.进程的组织形式 
​	进程
​	多个进程组成一个进程组    进程组的组长   session进程
​	多个进程组组成一个会话。







