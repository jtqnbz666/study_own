1. ES(Extra Segment):附加段寄存器
   DS(Data  Segment):数据段寄存器 	
   CS(Code Segment):代码段寄存器    配套IP:指令指针寄存器
   SS(Stack Segment):栈段寄存器     配套 SP:(stacj pointer):堆栈寄存器，存放栈的偏移地址。

2. 使用类似于A,D,E,U命令时
   D/A/E/U  **段地址**：偏移量

   若直接使用D,A,U命令时(如直接  -D 或 -A 或 -U)，默认使用的段寄存器是ds,不会是ss,cs,es,自己可以测试。E命令无法直接用，需要手动加上段地址和偏移量。

   如： 直接执行  -D  后边默认跟着段地址来自于数据段寄存器:ds，默认偏移量为0。

   D/A/E/U 命令也可直接 D  **段寄存器**：偏移量     可通过**r 寄存器   修改寄存器的值**

   -r ds
   :1000

   -d ds:0 查看从1000:0开始的内存区间中的内容

   -r ds
   :1000

   **-d ds:10 18 查看1000:10~1000:18中的内容(实际就是 九个数据)  //注意细节**

   若是  -d ds:0 18 则是查看1000:0~1000:18的内容，实际19个数据，注意细节

   -d  cs:0  查看当前代码段中的指令代码
   -d  ss:0  查看当前栈段的内容

3. 对于**MOV**  指令，实际上是对字节的操作还是对字的操作取决于你自己

   如：MOV AX,[0]			//这就是**对字**的操作，因为AX是一个十六位寄存器(两个字)，所以对于数据地址位置会把两个内存单元的值给到AX寄存器

   但其实可以把AX当作两个八位寄存器来看待（为了兼容8086的上一版，上一般的寄存器大小就是每个八位）
   如：MOV AL,[0]			//这就是**对字节**的操作，AX可被分为(AH)高位字节部分，(AL)低位字节部分。

   而对于**PUSH /POP的一切操作都是对字**的操作，也就是**两个字节**。
   		这里强调一点，sp(栈偏移量)不一定永远都是指在栈顶的位置（因为栈可能为空），如果此时栈为空，**sp的值为栈顶位置紧接着的下一位**。  8086中没有提供入栈出栈的越界的保护，因为偏移量最多就是在0~65535中，所以假设此时sp值为FFFFH,此时再出栈，sp+2后sp变成0001H，入栈也是一样的原理，就会出现对这段**栈空间的循环**，可能出现覆盖数据的情况，所以使用的时候要小心。

   对于PUSH操作，每次sp+2，对于POP，每次sp-2，**栈段的最大大小为64K。**

   因为栈段寄存器cs的值是不变的，对于偏移量寄存器sp是16位的寄存器，偏移地址范围最大也就是65535(64K-1)。

   举个例子：

   设栈空间为10000H~1000FH，若此时栈为空，那么SS:SP指向的位置是10010H**(即栈底的下一位)**

4. **MOV指令**可以在CPU内或CPU和存储器之间传送字或字节，它传送的信息可以从寄存器到寄存器，立即数到寄存器，立即数到存储单元，从存储单元到寄存器，从寄存器到存储单元，从寄存器或存储单元到段寄存器(注意立即数不能直接送段寄存器)，从段寄存器到寄存器或存储单元。

5. 对于一段内存而言，可以既是代码的存储空间，又是数据空间，还可以是栈空间，也可以什么都不是，对于这段内存是什么，完全取决于对CPU中相关寄存值的设置，即CS,IP,SS,SP,DS的指向

6. **不可**直接将数据mov给段寄存器(ss,cs,ds,es)，如mov ss 1000H,这样是错的，必须要一个中间寄存器来做媒介  如：
   mov ax,1000H			(H表示16进制，写入命令的时候不用加H)
     	mov ss,ax  //这样才是正确做法
   其实mov  ip,1000H也不行，但可以直接mov数据给sp（栈偏移地址） 如  mov sp,1000H	**最简单**使用的方法还是直接通过r ip来进行对所有寄存器值的更改

   **一切对段寄存器值的修改都可以通过一个中间寄存器来完成！！**

7. 在E,A,U中使用段寄存器
   -r   ds
   :1000

   -e  ds:0  11  22  33 44 55  66   在1000:0开始的内存区间写入数据
   -u   cs:0  //以汇编指令形式显示当前代码段中的代码，偏移量是0

   -r  ds
   :1000
   -a  ds:0  //以汇编指令的形式，向从1000:0开始的内存单元写入指令

8. Debug的T命令在执行修改寄存器SS的指令时，下一条指令也会紧接着被执行

   如：mov ss,bx       mov ss,[0]       pop ss   

9. 伪指令  

   - segment  和  ends

   一个段必须有一个名称来表示，使用格式为

   段名  segment
   .
   .
   段名  ends
   segment 说明段的开始，ends表示段的结束。

   ![1646026321358](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646026321358.png)

   

   **重点：这些段名最终会被编译、连接程序处理为一个段的段地址。**

   - end

   不要搞混了end和ends，ends是和segment成对使用的，表示一个段的开始和结束，而end表示的是整个程序的结束位置，当编译器看到end时，就知道程序是在这里结束的了。

   - assume

   只需记住assume就是将特定用途的段和相关的段寄存器关联起来

   如： assume cs:段名  //方便后续代码执行的时候好找到这个段的段地址

   ds 和 cs之间相差了256个字节，这个区域被称为PSP，**用途是DOS用来和程序进行通信。**

   **当程序加载入内存后，因为用了assume cs:段名，所以cs:ip自然是指向可执行程序入口，而ds中存放着程序所在内存区的段地址，内存区的地址为ds:0,内存区和可执行程序入口相隔了256个字节(PSP区)。**

10. 后缀名为.asm的是源文件(待编译文件)   用mask这个编译器来进行编译
    masm 待编译文件名		//如果是同一个目录下，否则用绝对路径
    link 待连接文件名    link 文件名.o    **根据提示**判断是否需要连接**库文件**

11. 程序加载过程

     DOS中有一个程序command.com,这个程序在DOS中称为命令解释器，也就是DOS系统的shell

     ![1646026260821](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646026260821.png)

     ![1646026281091](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646026281091.png)

     ![1646026829263](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646026829263.png)

12. [BX]和loop指令

      我们都知道 mov ax,[0] 其中[0]表示内存单元，它的偏移地址是0
      而 mov ax ,[BX]      其中[BX]同样也是内存单元只是它的偏移地址在BX寄存器中
      mov ax,[bx]   //将一个内存单元的内容送入ax，这个内存单元的长度为**2字节(字单元)**，存放一个字，偏移地址在bx中，段地址在ds中。
      mov  al,[bx]   //将一个内存单元的内容送到al，这个内存单元的长度为**1字节(字节单元)**,存放一个字节，偏移地址在bx中，段地址在ds中。

      

      loop指令(目的是为了循环)
      用cx 和 loop指令配合使用达到循环的目的，其中cx放循环的次数

      程序执行的时候，第一步是先将cx的值减一， 如果不等于0才修改ip的值继续循环，如果等于0了，就不会改变ip的值，而是接着往下继续执行新的指令

      框架如下：

      ​		mov cx, 循环次数
      s：循环执行的程序段
      ​		loop   s

      ![1646026361598](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646026361598.png)

      **在汇编语言中，标号代表一个地址，在这里面其实s是一个标号，它实际上标识了一个地址，这个地址处有一条指令：add ax,ax**

      

13. 定义的描述符号"(   )"

      （）内的元素可以有三种类型

      - 寄存器名 
      - 段寄存器名   
      - 内存单元的物理地址(一个20位的数据）

      比如：(ax)、（ds）、（al）、（cx）、（20000H）、（(ds)*16+(bx)）等都是正确的用法

      而  (2000:0)、（(ds):1000H)）等是不正确的用法

      （）内的数据只有两种类型:

      - 字节型   (al),(bl),(cl)这些就属于是字节型
      - 字型 ：（ax），（bx）就是字型

14. 在汇编语言中**数据不能以字母开头**

      如 mov  ax，ffffh   //这样是错误的。

      正确方法应该是 mov ax,0ffffh  //这样才是正确的

      同时注意，若只想将一个内存单元的值赋到ax之类的寄存器上
      方法： mov al,[0]
      			mov ah,0  
      **一定不可以直接mov ax,[0]**  因为这样操作的是字型数据,会包含**两个字节**的数据

15. 新出现的命令g 和 命令 p

      - g ：可通过g  想到达的执行位置(即程序执行到这个位置)

      比如现在程序是从1000:0 此时，cs=1000H，sp=0H

      若想直接将程序执行到1000:9处可以使用命令  g 0009

      - p：而p命令是当遇到loop循环时可使用，它会帮你一直循环完当前循环。

16. **Debug和汇编编译器masm对指令的不同处理**

      比如mov   ax,[0]	这条汇编代码  对于Debug来说，这里的[0]是地址偏移量
      而对于masm来说，它会认为这是一个实际数值0。

      解决办法：将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元
      比如：
      	mov  ax,2000h
      	mov  ds,ax				//段地址2000h送入ds
      	mov  bx,0				//偏移地址0送入bx
      	mov  al,[bx]			//ds:bx单元中的数据送入al

      这样确实可以，但比较麻烦，另一种方式：
      mov  ax,2000h
      mov  ds,ax
      mov  al,ds:[0]			//**区别在这里**，在偏移地址前显式给出端地址寄存器

17. **如何累加一段连续的数据单元？**（跟段前缀的使用区分开）

      我们会想到的两种方法

      - (dx)=(dx)+内存中8位数据
      - (dl)=(dl)+内存中的8位数据

      第一种方法问题是两个运算对象的类型不匹配

      第二种方法的问题是累加的结果可能越界

      正确方法是使用一个16位寄存器来做中间，配合loop命令使用

      ![1646035745327](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646035745327.png)

18. DOS和其他合法的程序一般不会使用0:200~0:2ff这段空间

19. **段前缀**

      mov ax,[bx] 内存单元的偏移地址由bx给出，**而段地址默认在ds中**，我们可以显示给出段地址所在的具体段寄存器  如下：

      - mov  ax,ds:[bx]
      - mov  ax,cs:[bx]
      - mov  ax,ss:[bx]
      - mov  ax,ss:[0]

      强调一点 mov [0],[1]  这种形式是错误的

20. **段前缀的使用**

      考虑一个问题，将内存fff:0~fff:b单元的数据复制到0:200~0:20b单元中：

      第一时间我们会想到，不就是利用一个中间寄存器来不断转换值吗？

      这里就有讲究了，不能直接将中间寄存器(bx)设置为0 ，为什么？

      我们首先要**知道0:200~0:20b与20:0~20:b是等价的**，**如果不把它看作等价的基础上就需要两个中间寄存器**      因为 偏移地址 前者是(200~20b),后者是(0~b)。

      ![1646038022235](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646038022235.png)

      可以发现每次loop循环都将寄存器ax的值修改了两次， 我们这里可以使用es(附加寄存器)，优化如下：![1646038193098](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646038193098.png)

      **真谛：因为可以显式给出段前缀，如果不加段前缀，默认的段地址用的是ds里面的值，而如果显示的给出段地址寄存器(cs,ss,es,ds)，段地址用的就是显示给出的段地址寄存器的值。**

21. 新出现的标号start

     程序框架：

     assume   cs:code
     code   segment
     		  .
     		  .

     ​		数据		 
     ​		  .

     start   .
     		  .
     		代码
     		  .
     code  ends
     end    start

     **超级重点：程序加载后：ds中默认存放着程序所在内存区的段地址(后边可以通过mov指令来调整ds存放的段地址为数据段的短地址**，后边会讲到。)

     ​						空闲内存区： ds：0  //ds的初始值由操作系统来分配决定。
     ​							PSP区	：ds：0~ds+10H:0
     ​							程序区：ds+10H：0
     **重点**：虽然程序区是ds+10H:0，但是程序的入口并不是ds+10H:0,本程序的入口是由end start 得到的，**这个程序入口将被写入到可执行文件的描述信息，可执行文件被加载入内存后，CPU的CS:IP被设置指向这个入口。**

     如果没有start 和 end start  可以理解为CS:IP的入口就是ds+10H:0。

     **重点**：用伪指令end描述了**程序的结束和程序的入口**，**由“end   start"指明的程序入口，被转化为一个入口地址**，存储在可执行文件的描述信息中，当程序被加载到内存之后，加载者(command,debug或其他程序)**从程序的可执行文件的描述信息中读到程序的入口，设置CS:IP。**

     **特别提醒：这里的框架是将数据段放入到代码段的，并不建议这样使用，应该将数据段，栈段，程序段分开，这里只是为了做演示**。

22. **超级重点**：
     我们在源程序中用的**伪指令”assume  cs:code,ds:data,ss:stack"将cs、ds、ss、分别和code、data、stack段相连，这样做了之后**，CPU是**不会将cs指向code,ds指向data，ss指向stack**，若要CPU按照我们的安排行事，就要用机器指令控制它，（**但最终就是指向它们这些位置的**）

     我们在源程序的最后用**“end  start”说明了程序的入口**，这个**入口被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始指向程序中的第一条指令。**![1646092841640](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646092841640.png)

     ![1646092877364](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646092877364.png)

     标号“start”在“code”段中，这样CPU就将code段中的内容当作指令来执行了。

     我们要知道一点，最终这上边的，**code，stack，data都会被翻译成一个数据**，在“code”段中，使用指令“

     ​	mov  ax，**satck**
     ​	mov  ss,   ax				不可直接：mov  ss,**stack**    错误语法

     ​	mov  sp，20h

     设置ss指向stack，设置ss:sp指向stack:20，CPU执行到这些指令后，将把stack段当作栈空间来用， 数据段同理。

     **如果没有start和end start的话，默认就根据操作系统会为你分配好ds的值，从而往后推256个字节(PSP)得到cs的值，同样将cs:ip的值保存在可执行文件的保存信息中，当CPU需要的时候就用这些信息来设置CS:IP寄存器的值。**

23.  大小写转换问题

     学到这里，还不知道用于判断的指令是哪个，如果不直接用判断指令，而利用所学，如何实现大小写的转换呢？
     这个时候就需要用到 **and(逻辑与)  和  or(逻辑或)** 来实现了，仔细观察大小写对应的二进制数你会发现，A和a(大写和小写)相差了20H，对应到二进制位上是第五位(从0位开始算)，所以可以使用与（and) 、或(or)来实现大小写的转换。

     ![1646101704047](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646101704047.png)

24. [bx+idata]的应用

     比如现在有两个字符串"BaSiC"和字符串”MinIX“，前者要求转换成小写，后者要求转换成大写。这时候如果不用[bx+idata]就需要进行两层loop，而使用[bx+idata]这种方式，直接在一层loop里面循环即可。
     	mov  bx，0；
     	前者的偏移地址为[bx],而后者的偏移地址直接写为[bx+5],这样就实现了只用一次loop循环。

     mov  ax,[bx+200]的含义：
     数字化描述:(ax)=((ds)*16+(bx)+200)

     **该指令的格式也可以改写成**
     mov  ax,200[bx]
     mov  ax,[bx].200

     **重点感受：**

     **C语言：a[i],b[i]**
     **汇编语言：0[bx], 5[bx]**

25. SI和DI

     si和di是8086CPU中和bx功能相似的寄存器，**si和di不能够分成两个8位寄存器来使用。**![1646103173904](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646103173904.png)

     **这把si和di都用上了，其实可以利用[bx(si或di)+idata]的方式，使程序更加简单**![1646103300026](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646103300026.png)

26. [bx+si]和[bx+di]

     mov  ax,[bx+si]

     数字化描述：(ax)=((ds)*16+(bx)+(si))

     该指令也可以改写为如下格式(常用)

     mov  ax,[bx] [si]

     mov  ax,[bx+si+idata]		使用方法类似

27. 不同寻址方式的灵活应用

     错误案例：![1646105220492](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646105220492.png)

     这是一个双层循环，仔细观察cx的指在等二层循环的时候被覆盖了。

     解决办法：1.cs只有一个，使用其他寄存器来暂存cs的值
     				不可行，寄存器本来就少，浪费了

     ​				  2.在数据段定义一个字，用来暂存cx

     ​				太麻烦
     ​				  3.使用POP，PUSH   ,非常好！

     ![1646105609631](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646105609631.png)

28. 一个最简单的加一操作

     分了三步

     mov  ax ,[0]
     add   ax,1
     mov  [0], ax

     **不能直接  add [0] ,1** ,也不能 add [0] [1]  ，也不能 mov [1],[2] 

29. 在[...]中，里面只能出现四种寄存器，bx，bp，si，dp，并且bx和bp  或  si，di不能出现在同一个[,,,]中，其它单个出现或组合都行(除以上两个组合)。

     mov ax,[bx+bp]  	
     mov ax,[si + di ]   				//这两种形式都是错的

     只要在[...]中使用寄存器bp，而指令中没有显式的给出段地址，那么**段地址就默认在ss中**，比如：

     mov  ax,[bx+idata]

     **数字描述：(ax)=((ss)*16+(bp)+idata)**

     mov  ax,[bp+idata]  
     **数字描述：(ax)=((ss)*16+(bp)+idata);**  

30. 指令执行要处理的数据是字节型还是字型

     在以前我们是通过观察寄存器的类型：如ax 则是字型，al或ah则是字节型。

     假设指令中没有了这些寄存器的出现，我们要采取新的办法  X ptr
     X 可以是word  也可以是  byte。 

     如：
     mov  byte ptr  ds:[0],1
     mov  word ptr  ds:[0],1
     inc   word ptr  ds:[0]

     特例：PUSH /POP 就不区分这些，因为它们两个一定是字型数据

31. 书上168页多看几次，体会过程，体会C语言结构体到汇编语言的相似之处

32. **div 指令(除法指令)**

    (1)除数：有8位和16位两种，在一个reg或内存单元中

    (2)被除数：**默认放在AX或（DX和AX）中**，如果除数为8位，被除数则为16位，默认在AX中存放，如果除数是16位，被除数则为32位，在DX和AX中存放，**DX存放高16位，AX存放低16位。**

    比如（除数为8位的情况）：

    div  byte  ptr  ds:[0]

    含义：(al)=(ax)/((ds)*16+0)的商

    ​			(ah)=(ax)/(ds)*16+0)的余数

    再比如（除数为16位的情况）

    div word ptr es:[0]

    含义：(ax)=[(ds) * 10000H+(ax)]/((es)*16+0)的商

    ​			(dx)=[(ds) * 10000H+(ax)]/((es)*16+0)的余数

33. **mul指令（乘法指令）**

    （1）两个相乘的树，要么都是八位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存**字节单元**中，如果是16位，一个默认在AX中，另一个放在16位reg或内存**字单元**中。

    （2）结果：如果是8位的乘法，结果默认放在AX中；结果是16位的乘法，结果高位默认在DX中，低位在AX中放。

    比如：

    mul  byte  ptr  ds:[0]

    (ax)=(al) * ((ds)*16+0)


    再比如：
    
    mul  word   ptr  [bx+si+8]
    
    (ax)=(ax) * ((ds)*16+bx+si+8)结果的低16位
    
    (dx)=(ax) * ((ds)*16+bx+si+8)结果的高16位
    
    **计算 100*10000**
    
    **100小于255，可10000大于255，所以必须做16位乘法**
    **mov ax,100**
    
    **mov bx,10000**
    
    **mul  bx**
    
    **结果：(ax)=4240H,(dx)=000FH   (F4240H=10000000)**

34. 伪指令dd

     dd 和dw，db 一样都是伪指令   它们就像C语言里面的变量类型一样(int )
     db  表示定义一个字节型数据	1字节
     dw  表示 定义一个字型数据	   2字节
     dd  表示定义一个双字型数据      4字节

35. dup的使用

     dp 3  dup(0) //表示定义了3个字节,且它们的值都位0，相当于 db 0,0,0
     dp  3 dup(0,1,2)定义了9个字节，相当于0,1,2,0,1,2,0,1,2,0,1,2
     dup的使用格式如下：

     db/dw/dd  重复的次数   dup(重复的数据)  	//重复的数据类型根据db/dw/dd而定

36. 转移指令

    可以修改IP(段内转移)，或同时修改CS和IP的指令(段间转移)

    段内转移又分为：短转移和近转移：
    短转移IP修改范围：-128~127
    近转移IP修改范围：-32768~32767

    这两者统称为转移指令.

    8086的转移指令分类：

    - 无条件转移指令(如：jmp)
    - 条件转移指令
    - 循环指令(如：loop)
    - 过程
    - 中断

37. 操作符offset

    相对于指令开始第一行的偏移量。

    ![1646178710966](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646178710966.png)

38. jmp指令（目的地址有三种情况，指令中，寄存器，内存）

     **一： 转移的目的地址在指令中的jmp指令：**

    

    **CPU在执行jmp指令的时候并没有给出需要转移的目的地址，而是给出到目的地址的位移量。**（这个**位移量**在**编译**的时候被算出来）
    包含  

    - jmp  short  标号()	短转移	，功能为：(IP)=(IP)+8位位移
    - jmp  newar ptr  标号	近转移 ，功能为：（IP)=(IP)+16位位移

    ​	8/16位位移=标号处的地址-jmp指令后的第一个字节的地址。

    - **jmp  far ptr   标号：实现的是段间转移，又称为远转移**
    **far  ptr 指明了指令用标号的段地址和偏移地址来修改CS和IP。**

  **(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址(书181页)**
    如果是标号位置在jmp指令上方，**偏移**量是负数，则用其对应的补码表示。**
**    

​       **二：  “转移地址在寄存器中的jmp指令**


​	  mov  ax  2233H

​	  jmp  ax			//**ax 中的值会覆盖IP**


​       **三：转移地址在内存中的jmp指令**

39. jmp  **word**  ptr  内存单元地址(段内转移)

  比如:

   mov  ax,0123H
     mov  ds:[0] ,ax
   jmp  word  ptr  [bx]

   执行后  **(IP)=0123H**

40. jmp  **dword**  ptr  内存单元地址（段间转移)

比如：

mov  ax,0123H
mov  ds:[0],ax
mov  word  ptr  ds:[2],0
jmp  dword  ptr  ds:[0]
**执行后,(CS)=0,(IP)=123H,CS:IP指向0000:0123**

**高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址**

41. jcxz指令（对IP修改范围-127~128)

当（cx）==0时,(IP)=(IP)+8位位移

当（cx）!=  0时，什么也不做

**如：if((cx)==0)  jmp  short  标号**

38. loop指令（对IP修改范围-127~128)

    (cx)--;

    if((cx!=0))  jmp  short  标号;

39. 形如  **jmp  2000:1000**  这样的转移指令，是在Debug中使用的汇编指令，汇编编译器并不认识，如果在**源程序**中使用，编译时也会**报错**。

40. **ret 和 retf**

    ret指令**用栈**中的数据，修改IP的内容，从而实现近转移

    retf指令**用栈**中的数据，修改CS和IP的内容，从而实现远转移

    ret:

    (1).  (IP)=((ss)*16+(sp))

    (2).  (sp)=(sp)+2

    整个过程相当于  **pop IP**

    retf：

    (1). (IP)=((ss)*16+(sp))

    (2). (sp)=(sp)+2

    (3).(CS)=((ss)*16+(sp))

    (4). (sp)=(sp)+2

    整个过程相当于

     **pop  IP**  

     **pop  CS**
    
42. call指令

    **第一种：**根据位移进行转移的call指令：

    **"call  标号"**  (将当前的IP压栈后，转到标号处执行指令)

    （1）(sp)=(sp)-2

      	  ((ss)*16+(sp))=(IP)

       (2) (IP)=(IP) +16

    整个过程相当于   

    push   IP

    jmp  near  ptr  标号（范围：-32768~32767)

    

    **第二种：**转移的目的地址在指令中的call指令

    **"call  far   ptr   标号"  实现的是段间转移**

    （1）(sp)=(sp)-2

    ​		((ss)*16+(sp))=(CS)

    ​		(sp)=(sp)-2

    ​		((ss)*16+(sp))=(IP)

    （2）**(CS)=标号所在段的段地址**

    ​		**（IP)=标号所在段的偏移地址**

    整个过程相当于

    push 	 CS

    push	  IP

    jmp  far ptr   标号

    

    **第三种：**转移的目的地址在寄存器中的call指令
    
     格式：call  (16位的)reg  **（reg表示除段寄存器的普通寄存器）**
    
    功能：(sp)=(sp)-2
    
    ((ss)*16+(sp))=(IP)
    
    (IP)=(16位的)reg
    
    整个过程相当于：
    
    push   IP
    
    jmp   (16位的)reg
    
    
    
    **第四种：**转移地址在内存中的call指令
    
    （1） call  word  ptr  内存单元地址
    
    ​	相当于： **push  IP**  	
    
    ​				**jmp    word   ptr   内存单元地址**
    
    
    （2）call  dword  ptr  内存单元地址
    
    ​	相当于： push  CS
    
    ​				push   	IP
    
    ​			jmp   dword   ptr    内存单元地址
    
43. call和ret 就是配合使用的，通过配合使用来实现函数返回的功能

44. 参数和结果传递的问题

    **用寄存器来存储参数和结果是最常使用的方法，对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器取到返回值；子程序从参数寄存器中取到参数，将返回值送入结果寄存器。**

    两道经典例题

    1. 设计一个子程序，可以根据提供的N，来计算N的三次方

    ![1646357557868](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646357557868.png)

    2.将一个全是字母的字符串转化为大写

    ![	·](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646357619386.png)

7. 标志寄存器PSW 

   ![1646371542340](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646371542340.png)

   ZF:记录相关指令执行结果是否为0，若是0，置为1，反之0。

   PF:奇偶标志位，记录相关指令结束后，结果的所有bit位中1的个数是否为偶数，如果1的个数为偶数，pf=1，如果为奇数，那么pf=0。

   SF:**记录相关指令执行后，结果是否为负，如果结果为负，sf=1；如果非负，sf=0。**

   **重点：SF是CPU对  有符号数运算  结果的一种记录**

   比如：

   00000001B   ，可以看作为无符号数1，或有符号数+1；

   10000001B  ，可以看作无符号数129，也可以看作有符号数-127

   CF：**(进位/借位）**标志，如两个8位数据相加，98H+98H，将产生进位，有进位CF就置位1，无进位则置0.

   **如：**

   ​	mov  al,98H

   ​	add  al,al		执行后:(al)=30H,CF=1

   **再如：**

   两个八位数据，97H-98H，将产生借位，借位后，相当于计算197H-98H.

   ​	mov al,97H
   ​	sub  al,98H	执行后：(al)==FFH,CF=1,CF记录了向更高位的借位值。
   ​	sub  al,al   执行后：(al)=0,CF=0,CF记录了向更高位的借位值

   

   OF:溢出位，在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出，这里所讲的**溢出是对于有符号数的运算**。

   如：

   mov  al,98

   mov  al,99

   执行后将产生溢出。

   (al)=(al)+99=98+99=197

   而197这个结果超出了机器所能表示的有符号数的范围：-128~127

45. **CF和OF的关系**

    **CF是对无符号数运算而言的，而OF是对有符号数运算而言的。**
    补充：**SF**也是对于有符号数而言的。

46. adc指令
       带进位加法指令，它利用了CF位上记录的进位值。

   **比如：add  ax,bx	 相当于：(ax)=(ax)+(bx)+CF**

   直接通过两个例题就能看明白：

   

   一、计算1EF000H+201000H,结果放在ax(高16位)和bx(低16位)中。

   ​	因为两个数据的位数都大于16位了，用add指令无法计算， 所以我们将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。

   ​	mov  ax,001EH
   ​	mov  bx,0F000H

   ​	add  bx,1000H
   ​	adc  ax,0020H

   二、计算1EF0001000H+2010001EF0H,结果放在ax(最高16位)，bx(次高16位)，cx(低16位)中。

   ​	mov  ax,001EG
   ​	mov  bx,0F000H
   ​	mov  cx,1000H
   ​	add   cx,1EF0H
   ​	adc   bx,1000H
   ​	adc   ax,0020H

48. sbb指令

    sbb是带借位减法指令，它利用了CF位上记录的借位值
    比如 sbb  ax,bx     相当于:(ax)=(ax)-(bx)-CF

    计算：003E1000H-00202000H

    mov bx,1000H
    mov  ax,003EH
    sub   bx,2000H
    sbb   ax,0020H

49. **cmp指令(比较指令)**

    cmp是一个比较命令，功能相当于减法指令，只是不保存结果，cmp指令执行后，将对标志寄存器产生影响，其他相关指令通过识别这些被影响的标志寄存器来得知比较结果。

    重点：当通过SF这个标志位无法准确判断大小关系，SF标记的是最终得到的**实际结果的正负**，不一定是**逻辑上真正结果的正负**，因为可能会出现溢出的情况，所以单凭SF这个标志位无法准确判断，所以**还需考察OF(得知有没有溢出)**，就可以得知逻辑上真正结果的正负。

    ![1646548518870](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646548518870.png)

50. 检测比较结果的条件转移指令(跟cmp息息相关)

    | 指令             | 含义         | 检测的相关标记位 |
    | ---------------- | ------------ | ---------------- |
    | je  (equal)      | 等于则转移   | zf=1             |
    | jne  (not equal) | 不等于则转移 | zf=0             |
    | jb  (below)      | 低于则转移   | cf=1             |
    | jnb              | 不低于则转移 | cf=0             |
    | ja   (above)     | 高于则转移   | cf=0且zf=0       |
    | jna              | 不高于则转移 | cf=1或zf=1       |

    这些是常用的根据**无符号数**的比较结果进行转移的条件转移指令。

    **若是有符号数(检测 sf、of和zf的值)**

    这些条件转移指令一般都是跟着cmp搭配使用的，就像call和ret搭配使用。

    实际用处相当于高级语言中的  if  判断语句。

51. DF标志和**串传送指令(movsb\movsw)**

    方向标志位，在串处理指令中，控制每次操作后si、di的增减。
    df=0	每次操作后si、di递增
    df=1	每次操作后si、di递减 

    **cld**指令：将标志寄存器的df位置0
    **std**指令：将标志寄存器的df位置1

    **重点：配合rep一起使用：**

    我们来看一个**串传送指令**：

    格式：movsb

    功能：执行movsb指令相当于进行了下面**几步**操作。

    (1)	**((es)*16+di))=((ds) * 16+(si))**

    (2)	如果df=0则：  (si)=(si)+1

    ​								(di)=(di)+1
    ​		如果df=1则：   (si)=(si)-1
    ​								 (di)=(di)-1

    串传送指令movsw也跟movsb同理，只是**movsw是对于字单元**的操作，而**movsb是对于字节单元**的操作。

    movsw和movsb一般都和rep配合使用：

    rep	movsb

    **rep的作用是根据cx的值，重复执行后面的串传送指令。**

    用汇编的语法来描述rep  movsb的功能就是：

    **s：movsb**	（记住movsb或movsw是**串传送指令，相当于进行了几步操作。**）

    ​	**loop   s**

52. pushf和popf

    pushf的功能是将**标志寄存器**的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。

53. 标志寄存器在Debug中的表示

    ![1646553615913](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1646553615913.png)

54. 内中断

    **产生：**

    - 除法错误，比如，执行div指令产生的除法溢出		对应中断类型码：0
    - 单步执行（Debug，利用TF=1来实现）  对应中断类型码：1
    - 执行into指令			对应中类型码  ：4
    - 执行int指令 			对应中断码：N(立即数)，格式  int  N

    **重点**：中断信息中包含有标识中断源的类型码，这个类型码的作用就是用来定位中断处理程序的，通过类型码在中断向量表中找到对应项，从而得到中断处理程序的入口。 

    **中断向量表在内存中存放**，对于8086PC机，中断向量表指定放在**内存地址0处。**从内存0000:0000到0000:03FF的1024个单元存放着中断向量表。

    入口地址包含段地址和偏移地址，所以**一个表项占两个字的大小**，高地址存放段地址，低地址存放偏移地址。

    简述中断过程：

    (1)取得中断类型码

    (2)pushf

    **(3)TF=0,IF=0**			**必不可少，TF跟Debug单步调试有关**

    (4)push  CS

    (5)push  IP

    (6)(IP)=(N*4),(CS)=(N * 4+2)    为什么是4，因为一个表项占两个字的大小。

    

    中断处理程序和iret指令：

    中断处理程序即是发生中断后，CS和IP根据中断向量表获得入口地址的对应程序。整个执行过程如下：

    (1)保存用到的寄存器

    (2)处理中断

    (3)恢复用到的寄存器

    (4)用iret指令返回

    iret指令的功能用汇编语法描述为：

    pop  IP

    pop  CS

    popf

    

    **中断处理程序(如:int) 和 iret 是配套使用的，有点像 call 和 ret 配套使用**。

    **重点**：安装中断程序所需的数据信息，不能简单的放在数据区(data区)，因为程序执行完后，data区会被释放，可能导致原来的内容被覆盖，所以这部分所需的数据应该直接放在中断处理程序当中，通过一定方法修改CS、IP的值加以利用这部分数据。

    响应中断的特殊情况：补了上边的坑为什么每次执行T命令后，只要是**修改了ss寄存器**的值，**会连着执行两条命令**，因为ss属于栈段指针，修改的同时**必须**要对ip也修改，否则可能出错，就比如ss改变了(若只执行一条命令)，突然出现中断去执行其他影响ss、ip值的指令，就会导致ip的值不正确。

55. int 指令：

    int指令也会出现内中断，使用格式int  n，n为中断类型码，它的功能是引发中断过程。

    **int指令和iret指令的配合使用与call指令和ret指令的配合使用具有相似的思路。**

56. BIOS和DOS所提供的中断例程

    BIOS主要包含以下几部分内容

    - 硬件系统的检测和初始化程序
    - 外部中断和内部中断的中断例程
    - 用于对硬件设备进行I\O操作的中断例程
    - 其他和硬件系统相关的中断例程

    操作系统DOS也提供了中断例程，从操作系统的角度来看,DOS的中断例程就是操作系统向程序员提供的编程资源。

    开机后,CPU一加电，初始化(CS)=0FFFFH,(IP)=0,自动从FFFF:0单元开始执行程序，FFFF:0处有一条跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。

    初始化程序功能：将BISO所支持的中断例程的地址登记在中断向量表中，对应BIOS所提供的中断例程，只需将入口地址登记在中断向量表中，因为它们是固化到ROM中的程序，一直在内存中存在。

    硬件系统检测和初始化完成后，调用int  19h进行操作系统的引导，从此将计算机交由操作系统控制。

    DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。

57. BIOS中断例程应用

    **重点：**一般来说，一个供程序员调用的中断例程中往往包括了**多个子程序**，中断例程内部用传递进来的参数来决定执行哪一个子程序，BIOS和DOS提供的中断例程，**都用ah来传递内部子程序的编号。**

58. DOS中断例程应用

    int  21h中断例程就是DOS提供的中断例程的4ch号功能，如下：

    mov  ah ，4ch	程序返回
    mov  al，0		返回值
    int   21h

59. 端口：

    在PC机系统中，和CPU通过总线相连的芯片除各种寄存器外，还有以下3种芯片

    - 各种接口卡（比如，网卡，显卡）上的接口芯片，它们控制接口卡进行工作
    - 主板上的接口芯片，CPU通过它们对部分外设进行访问
    - 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。

    在这些芯片中，**都有一组可以由CPU读写的寄存器**，这些寄存器，它们在物理上可能处于不同的芯片中，但是它们有以下两点上相同

    （1）都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的

    （2）CPU对它们进行**读或写**的时候都**通过控制线向它们所在的芯片发出端口读写命令。**

    可见，从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间，每一个端口在地址空间中都有一个地址。

    

    对端口的读写不能用mov、push、pop等**内存读写指令**，端口的读写指令只有两条：in和out，分别用于**从端口读取数据和往端口写入数据。**

    CPU可以直接读写以下3个地方的数据

    （1）CPU内部的寄存器

    （2）内存单元

    （3）端口

    我们来看以下CPU执行内存访问指令和端口访问指令时，总线上的信息

    （1）访问内存：

    ​	mov  ax,ds:[8]		假设(ds)=0
    执行时与总线相关的操作如下所示

    - CPU通过地址线将地址信息8发出
    - CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据
    - 存储器将8号单元中的数据通过数据线送入CPU

    （2）访问端口

    in   al，60h   从60h号端口读入一个字节

    执行时与总线相关的操作如下

    - CPU通过地址线将地址信息60h发出
    - CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据
    - 端口所在的芯片将60h端口中的数据通过数据线送入CPU

    注意：在in和out指令中，**只能用ax或al**来存放从端口读出或写入的数据，访问8位端口时用**al**，访问16位端口时用**ax。**

60. shl和shr指令（左移，右移）

    如： shl  al,1

    左移一位，被移出来的那位保存在CF中。

    如果移动位数大于1时，必须将移动位数放在cl中

    如：mov  al ，01010001b
    		mov  cl，3
    		shl  al，cl

61. 外中断

    还记得内中断的步骤吗

    (1)取得中断类型码

    (2)pushf

    **(3)TF=0,IF=0**			**必不可少，TF跟Debug单步调试有关**

    (4)push  CS

    (5)push  IP

    (6)(IP)=(N*4),(CS)=(N * 4+2)    为什么是4，因为一个表项占两个字的大小。

    

    外中断分为**两种**：**可屏蔽中断和不可屏蔽中断**

    对于**可屏蔽中断而言**，除了第一步的实现上有所不同，基本上和内中断的中断过程相同。 因为**可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线传入CPU的，而内中断的中断类型码是CPU内部产生的。**

    

    可屏蔽中断是CPU**可以不响应**的中断，CPU是否响应可屏蔽中断，要看标志寄存器的IF 位的设置，当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程，如果IF=0，则步响应可屏蔽中断。

    现在我们可以中断过程中要将IF置位0的原因了，**原因就是，在进入中断处理程序后， 禁止其他的可屏蔽中断。**

    sti：设置IF=1；
    cli：设置IF=0。

​		第二种是**不可屏蔽中断**，不可屏蔽中断是CPU必须响应的外中断，当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。

重点：CPU通过端口和外部设备进行联系。

62. PC机键盘的处理过程

    一、键盘输入

    键盘中的每一个键相当于一个开关，**键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。**

    按下一个键时，开关接通，该芯片就产生了一个扫描码，扫描码说明了按下的键在键盘上的位置，**扫描码被送入主板上的相关接口芯片的寄存器中**，该寄存器的端口地址在60h。

    松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中。

    一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码长度为一个字节，通码的第7位为0，断码的第七位为1

    **即  断码=通码+80h**

    二、引发9号中断
    键盘的**输入到达60h端口时**，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息，CPU检测到该中断信息后，**如果IF=1，则响应中断**，引发中断过程，转去执行int  9中断例程

    三、执行int  9中断例程

    （1）读出60h端口中的扫描码：

    （2）如果是**字符键**的扫描码，将该扫描码和它所对应的字符码(即ASCII码)送入内存中的BIOS键盘缓冲区；如果是**控制键**（比如  Ctrl）和切换键（比如 CapsLock）的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换健状态的字节)写入内存中存储状态字节的的单元。2

    （3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。

    BIOS用于存放int 9中断例程所接收的键盘输入的内存区，该内存区**可以存储15个键盘输入**，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个**字单元**存放，**高位字节存放扫描码，低位字节存放字符码。**
    
    **0040：	7单元存储键盘状态字节，该字节记录了控制键和切换键的状态。**
    
63. 描述了单元长度的标号**(数据标号)**

    如：

    assume  cs:code
    code   segment

    ​	a  db  1,2,3,4,5,6,7,8
    ​	b  dw  0

    start ：

    ​		s:mov  al,**a[si]**
    ​		mov ah,0
    ​		**add  b,ax**
    ​		mov  ax,4c00h
    ​		int  21h
    code   ends
    end    start

    仔细观察以上对于标号a，标号b的用法。**（普通的用法，a和b后边都会有：，但这里没有。）**

    举两个例子
    指令：mov  ax，b

    相当于：mov  ax，cs:[8]

    指令：mov  b，2

    相当于：mov  word  ptr  cs:[8],2

    **可以看出这里的标号a和标号b同时描述了内存单元地址和单元长度。**

64. 在其他段中使用数据标号

    注意上边这一条中，标号a和b都处于代码段中，若是此时将a，b都放到单独的一个段(数据段)，那么需要用伪指令assume将数据段与一个寄存器相连(这里我们用ds)，等到真正用到标号a和标号b时，**默认的段地址为ds。**

    这种情况下，可以将**数据标号当作**数据来定义

    如：

    data  segment

    ​	a  ds  1，2，3，4，5，6，7，8

    ​	b  dw  0
    ​	c  **dw**  a,b
    data  ends
    数据标号c处存储的两个字节型数据为标号a、b的偏移地址。

    相当于  c  dw  offset  a，offset  b

    再如：

    data  segment

    ​	a  ds  1，2，3，4，5，6，7，8

    ​	b  dw  0
    ​	c  **dd**  a,b
    data  ends

    相当于: c  dw  offset  a,seg  a,offset  b,  seg  b
    **seg操作符，功能为取得某一标号的段地址。**

65. int  9中断例程对键盘输入的处理

    在CPU执行完int  9中断例程后，都放到了键盘缓冲区中，键盘缓冲区中有16个字单元，**可以存储15个按键的扫描码和对应的ASCII码**。

    过程：按下某一个B键，引发键盘中断，从60h端口读出B键，然后检查状态字节是否有切换键按下，将B键的扫描码30h和对应的ASCII码，即字母**”b“的ASCII码62h**写入键盘缓冲区。

    若按下一个B建，此时发现有切换键按下(比如shift)，即将B健的扫描码30h和对应的ASCII码，即字母**"B"的ASCII码42h**写入键盘缓冲区。

66. int  16h 中断例程读取键盘缓冲区

    mov  ah，0  （此功能对应编号为0，前边说过，一个中断例程包含多个子程序）

    int  16h

    //一般ah是内部子程序的编号

    **结果：(ah)=扫描码 ,（al）=ASCII码**

    读取一个键盘输入，并将其从键盘缓冲区中删除。

    **重点：int  16h中断例程检测键盘缓冲区，发现缓冲区为空，则循环等待，直到缓冲区有数据**

    int  9和int  16h配套使用。

67. int  13h中断例程对磁盘进行读写

    磁盘的实际访问由磁盘控制器进行(需要涉及很多硬件细节），但BIOS提供了对扇区进行读写的中断例程

    入口参数：

    一：

    (al)=int 13h的功能号(2表示读扇区)
    (al)=读取的扇区数
    (ch)=磁道号
    (cl)=扇区号 
    (dh)=磁头号(对于软盘即盘面，因为有一个面用一个磁头来读写)
    (dl)=驱动器号    软驱从0开始，0：软驱A，1：软驱B
    												硬盘从80h开始，80h：硬盘C，81h：硬盘D
    **es:bx指向接收从扇区读写的内存区**

    二：

    (al)=int 13h的功能号(3表示写扇区)
    (al)=写入的扇区数
    (ch)=磁道号
    (cl)=扇区号
    (dh)=磁头号(对于软盘即盘面，因为有一个面用一个磁头来读写)
    (dl)=驱动器号    软驱从0开始，0：软驱A，1：软驱B
    												硬盘从80h开始，80h：硬盘C，81h：硬盘D
    **es:bx指向接收从扇区读写的内存区**

    

    返回参数：

    操作成功：（ah）=0，（al）=读入/写入的扇区数

    操作失败：（ah）=出错代码。
    
    