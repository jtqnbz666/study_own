## 2.3 七道

自我介绍需要改进，

1.c++类和结构体区别。

~~~c
struct 能包含成员函数
struct 能继承
struct 能实现多态
struct 也能用模板
最本质的一个区别就是访问控制权限，struct默认是public，class默认是private；
c++之所以引入结构体有一点也是为了跟C保持兼容性

c和c++中结构体区别：
c中需要加上 struct 定义对象，或者用typedef 的方式
c中结构体对象不能包含成员函数
c中不能为对象初始化
c中没有权限访问控制
c中没有继承多态
C语言中，空结构体的大小为0，并且不允许为空，至少要包含一个对象，而C++中空结构体（属于空类）可以为空，并且大小为1


~~~



2.static

~~~
初始化的对象在data区，未初始化在.bss段
不同文件中，不会出现名字冲突的问题了
pthread_create第四个参数
单例模式
类中的static 函数只能访问static成员

可以延展空指针可以访问成员函数(前提是不要设计到成员对象)， 以及如何才能访问到虚函数，虚函数表地址是对象生成后的第一个成员

可以延展为什么静态局部变量不放在栈上（因为生命周期问题）
也因为static 变量是编译时就放在数据段(分为.bss 和 .data)的，所以不宜太多，不然文件就会很大。
~~~



3.c++内存模型问题

通过**size** 命令可以查看各段的情况

可以衍生栈和堆的区别,有必要可以延展一下汇编中入栈原理(寄存器指针记录)

~~~
a和b同为全局变量，但是a没有初始化，b初始化，它分布在不同的两个地方（.bss,.data）
a和c同为未初始化变量，但是a不是静态，c是静态, 他们分布在.bss的不同地方
b和d同为初始化变量,d是静态，它们分布在.data的同一个地方
c和d同为静态变量，c没有初始化，d初始化，它们分布在两个不同地方(.bss .data)

初始化为0 也放在.bss 段， 对于数组也是。比如int arr[5000]; 或者int arr[5000] = {0}, 同样只是在bss段预留大小，但实际上是不占用磁盘空间的，但如果是int arr[5000] = {1}; 则会显式是在.data段， 并且会占用磁盘的空间  
可以看出， 对于.bss 它都只是预留了空间大小，并不实际占用磁盘空间。

如果在函数中写 int arr[5000] = {1}; 它只是占文本区(.text)的大小，跟.bss 和 .data没有关系。

.text, .data, .bss都是在编译时就能确定好的， .stack, .heap 是运行时分配的
~~~

4.谈到lua就往lua实现类拉扯

~~~lua
local Account =  {value = 1000}
function Account:new(o) 
  o = o or {}
  setmetatable(o, self);
  self.__index = self
  return o
end
function Account:display() 
	self.value = self.value + 100    
    print(self.value)
end

-- 对象的实例
local a = Account:new{} -- 传入一个表的时候可以不用加括号
a:display() -- 100.  相当于调用 a.display(a);

~~~





5.1000万个数字中找到某一个是否存在

~~~
位图，布隆过滤器，redis中的hype log log
~~~

6.访问类中的对象有几种方式：

~~~
1.通过对象 . 或 ->
2.接口
3. 通过对象成员的偏移量也可以  核心是抓住地址是16进制，long是10进制
求对象偏移量方式：
cout << (size_t)(&((test*)0)->b) << endl;
如：
cout << (size_t)(&((test*)0)->b) << endl;//8,成员b的偏移量
    size_t gg = (size_t)(&t)+ (size_t)(&((test*)0)->b);
    cout << (void*)&t << ":" << (void*)gg << endl;//0041F7EC::0041F7F4,对象的地址，对象成员偏移后的地址
    *(double*)gg = 9.9;
    cout << t.b << endl;//9.9,可见对象可以通过偏移量找到成员并操作它的成员
    
 4.通过偏移量的方式用虚指针访问虚表然后调用函数
 typedef void (*func)();
 A* a = new A;
 long address = *(long*)a;  //address就是第一个指针，但以long类型记录下来了，所以下边需要转换成指针类型,这里的address的值和下边的(long*)address的值是一样的，只是前者是10进制，后者是16进制， 机器只认16进制机器码， 它会把你的10进制当作16进制来读，所以自然会地址访问错误，所以需要先转换为16进制。
 
func fun1 = (func)(*(long*)address);
func fun2 = (func)(*((long*)address + 1));
这个fun1 就是 虚函数表的第一个函数


拓展一点知识：
int a = 15 ;
cout << *(long*)a << endl; // 这样是错的，相当于去访问了0x0000000F这个地址越界。
因为(long*)a , 并不是 &a; 
~~~

## 2.6 贝格迈思

1.gdb调试

2.进程通讯方式

3.线程同步问题

4.I/O多路复用区别

总结：拓展I/O多路复用连招，哈希连招

### 2.8莉莉丝

1.操作系统内存模型

2.free命令的buffer/cache含义

3.shell脚本的编写
检查用户，判断资源是否存在

4.项目感触最深的事情

5.Nginx的用处
反向代理，负载均衡

6.问过go也没有做过项目
这里可以拓展数组切片， 接口，反射机制，go的协程

## 2.14 360 一面

项目， 红黑树和hash，合并两个有序链表， 单词逆转

## 2.14 360二面

网络库封装前后有什么区别。

select 和 epoll区别

c++右值主要解决什么问题？

虚函数的实现原理

lamda表达式的实现原理

CAS了解过吗, aba问题， 加一个stamp标记，防止多次做同一件事，少于20冲10块的活动，不能一直这么干，只享受一次活动

gdb如何查看当前的线程数量

A,B两个字符串， 如果A字符在B中出现，则删除A中的这个字符。

string str = "";

for循环， str += 一个字符   		//提示说底层库这种写法效率低，如何优化，不懂。(预先开辟空间)

## 2.15 七牛云

c 和 c++的区别

虚函数的实现

go语言有没有做过什么项目

go语言数组和切片有什么区别

聚簇索引和非聚簇索引

zset可以做些什么

mysql三大范式

mysql场景， 学生，老师，课程， 多表联合设计

5.09猴喜

项目

http方法

go跟c++比，go的缺点

go分布式缓存设计

go的map是乱序遍历的吗 (脑子短路，应该就是说hash表)

