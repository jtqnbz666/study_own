# 操作系统-项目总结

## 基础知识

### 如何控制CPU的下一条指令

- 概念内容：程序计数器PC
- 在X86体系中CS和IP是待执行的下一条指令的段基址和段内偏移量

## 内存低1M布局图

![image-20230124130118865](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124130118865.png)

## 物理内存与物理地址空间

- 计算机中的内存靠地址总线进行访问，地址总线能够寻址到的空间叫做物理地址空间
- 实际在计算机里面物理内存不单单指的是内存条里面的内存，还有外设的一些内存，比如BIOS所在的ROM，显存，还有一些外设的寄存器映射到内存
- 32位会存在地址总线分出去一些去访问其他内存，所以内存条里面的内存不可能物尽其用，64位不存在这样的问题，但是64位机子也会出现内存条大小与显示的可用大小不同，原因是因为有共享显存，所谓的共享显存是用内存作为显存来提高低端显卡的性能，内存条里面的内存分了一部分出去做显存使用

## 实模式与保护模式

![image-20230124140638391](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124140638391.png)

## 保护模式

- 地址总线使用32位，寻址范围2^32B=4G
- 通用寄存器(8个:EAX,EBX,ECX,EDX,EBP,ESP,ESI,EDI),标志寄存器,指令指针寄存器(EIP)扩展到了32位，段寄存器没变
- 依然采用段基址(选择子)：段内偏移地址的访问策略，但引入了全局描述符表，由此间接安全的访问内存
- 段寄存器里面放的不再是段基址，而是选择子(可见部分)，要从段描述符中(段寄存器的不可见的缓存部分)获取段基址

## 全局描述符表GDT

- 全局描述符表里面存放的是描述符
- 在实模式下段基址就在段寄存器，可直接获取，但是保护模式下获取段基址没那么容易，段寄存器里面存放的是段选择子，需要根据段选择子去索引段描述符，从而获取段基址，这期间还会有特权级检查等，因为增加了段描述符这一层，所以安全，是为保护模式
- 全局描述符表位于内存中，GDTR寄存器用来存储GDT的线性地址和大小

## 段描述符

- ![image-20230124142332046](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124142332046.png)
- 段基址，被分散到了三个部分，平坦模式下一般是0
- 段界限与G位，段界限表示一个段的边界扩展最值，也就是表示一个段最大能有多大，G表示单位，0表示1B，1表示4kb,段界限这个数值和G这个单位两者一起才有意义，段界限共20位，故段的最大值要么是1M要么是4G
- P位,Present,表示该段是否在内存中，若在P为1，反之为0
- DPL,描述符特权级，0最高，3最低
- S位，为0表示系统段，为1表示代码段或者数据段，所谓系统段是有硬件支持的段或者说硬件运行所需要用到的段，比如说中断机制，中断来临时，硬件自动处理，但是我们需要提供中断处理程序才能正常运行，这个中断服务程序所在段可叫做系统段，也叫做中断门结构，各种门结构都是系统段
- TYPE，段的类型，不同的段有不同的取值
- 段描述符与内存段的关系
  - ![image-20230124144546607](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124144546607.png)

## 段选择子

- ![image-20230124144619227](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124144619227.png)
- 段选择子放在段寄存器的可见部分,全局描述符表GDT类似于一个大数组,段选择子的描述符索引值(index)就是这个数组的下标，指向一个描述符,描述符索引值有13位，说明最多表示2^13=8192个段，也就是说GDT里面最多存放8192个描述符
- 第0个描述符没有使用，主要是为了防止选择子忘记初始化而选择到第0个段描述符的情况
- TI为0表示全局描述符GDT，TI为1表示局部描述符表LDT，LDT一般不用
- RPL,请求特权级，主要拿来进行特权级检查

## 段寄存器

- 每一个处理器有6个段寄存器，CS代码段，SS栈段，DS数据段，ES FS GS附加数据段
- 段描述符是在内存中，访问内存对CPU来说是比较慢的动作，效率不高
- 段描述符的格式奇怪，一个数据要分三个地方存，为了提高获取段信息的效率，对段寄存器应用缓存技术，将段信息用一个寄存器来缓存，这就是段描述符缓冲寄存器，CPU每次获取到的内存段信息，整理成完整，通顺的形式后，存入段描述符缓冲寄存器，以后每次访问相同的段时，就直接读取该段寄存器相应的段描述符缓冲寄存器
- 要访问一个内存段的时候，这个段的段选择子必须加载到某段寄存器，所以一个系统虽然可以定义上千个段，但是单处理器的情况下，当前使用的段最多只有6个
- 每个处理器都有6个段寄存器，有各自的GDT，有各自定义的内存段

## 控制寄存器

- 每个处理器有5个控制寄存器,每个寄存器32位
- CR0
  - ![image-20230124152912168](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124152912168.png)
  - PE位，置1表示保护模式，0表示在实模式下
  - PG位，置1表示使用分页机制，0反之
- CR2，发生缺页异常的时候，CR2里面就会存放引发缺页的那个地址
- CR3，存放页目录的物理地址
- CR4
  - PSE位，置1表示页面大小扩展为4M，配合页目录项PS位使用

## 特权级

![image-20230124153604794](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124153604794.png)

- DPL，描述符特权级，为描述符的DPL位域
- RPL，请求特权级，为选择子的RPL位域
- CPL，当前特权级，CPL的值其实是当前正在执行的代码段描述符的DPL位域值



## 进入保护模式

进入保护模式分三步

- 打开A20
- 构建加载GDT
- 设置CR0的PE位

## 打开A20

地址线的编号从0开始，实模式下只用了其中20根即A0-A19，这是因为A20Gate的存在，他可以控制A20地址线的有效值，而实模式下是将A20关闭了的，因此只要打开A20便可突破1M的局限性，访问更大的内存空间

打开A20一般有三种方法：

- 利用键盘控制器
- 通过BIOS中断
- 通过系统端口0x92

本人所写操作系统采用第三种方法，将端口0x92的第1位置1就可以了，以下三步就可以实现

![image-20230124160215096](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124160215096.png)

## 构建加载GDT

GDT是硬件支持的一个数据结构，专门有个寄存器GDTR指示GDT的起始位置和大小，GDT的位置信息记载到GDTR之后，CPU才知道GDT在哪

![image-20230124160556628](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124160556628.png)

GDTR寄存器存放了32位的地址信息和16位的界限，这48位数据信息就把GDT的位置定下来了，16位的界限，说明GDT最大为2^16=8*2^13,每个描述符8B，所以最多2^13=8192个描述符

加载GDT有专门的指令，lgdt m16&&32，GDT构建好之后，使用lgdt指令将其位置信息加载到GDTR寄存器便完成了加载GDT的过程

GDTR里面存放的是物理地址

## 将CR0寄存器PE位置1

将CR0寄存器PE位置1，表示进入保护模式，此后所有地址都是逻辑地址

## 内存碎片

- 内存碎片描述一个系统所有不可用的空闲内存
- 内存碎片分为外部碎片和内部碎片
  - 内部碎片：因为所有的内存分配必须起始于可被4，8或16整除的地址或者因为分页机制的限制，决定内存分配算法仅能把预定大小的内存块分配给客户，假设当某个客户请求一个43字节的内存块时，因为没有合适大小的内存，所以它可能会获得44字节，48字节等稍大一点的内存，因此由所需大小四舍五入而产生的多余空间就叫内存碎片
  - 外部碎片：原因在于空闲内存比较小且不连续方式出现在不同的位置，使得系统无法满足当前申请

## 分页机制

x86结构下分段是必须的，分页不是必须的，GDTR GDT 段寄存器等等这些硬件设施和数据结构激素拿来段式管理的，很多人会认为分段有很多弊端，所以没有使用分段机制，这是错误的，X86的分段是刻在骨子里的，访问内存始终采用段基址：段内偏移的策略，只是保护模式下段基址需要通过段选择子来转换

分页的本质就是将各种大小不同的内存段拆分成大小相同的内存块(通常4KB)，以便进行内存管理的一种机制

在存分段情况下会出现很多问题，如应用程序过多，或者内存碎片过多而无法容纳新进程，又或者重新加载某内存段时，找不到合适的内存区域

找出这情况的原因:只分段的情况下，线性地址就是物理地址，两者都是连续的，不够灵活，不可能每次都能找到合适的内存区域，而分页的话，线性地址需要进一步转换为物理地址，线性地址是连续的，但物理地址可以不连续

这意味着可以在物理内存上找块地，只要线性地址和物理地址建立起映射关系就好

## 一级页表与多级页表

### 页级地址转换

首先先看地址转换过程

![image-20230124171441750](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230124171441750.png)

### 为什么一级页表不适用，为什么多级页表比一级页表省空间

采用一级页表的方式，一级页表是20-12，20表示一级页表有2^20=1M个页表项，12表示页的大小为2^12=4KB,所以这个大页表就占用4M内存，一级页表中所有页表项必须要提前建好，原因是操作系统要占用4GB虚拟地址空间的高1GB,用户进程要占用低3GB，而大页表就像一个数组，数组无法分割开来，每个进程都有自己的页表，进程一多，页表占用的空间就很大了

采用多级页表可以解决该问题，以二级页表为例，标准页的尺寸都是4KB，所以4GB线性地址空间最多有1M个标准页，二级页表是将这1M个标准页平均放置1K个页表中，每个页表中包含有1K个页表项，页表项是4字节大小，页表包含1K个页表项，故页表大小为4KB，每个进程的只需要有页目录表和有映射建立的页表，没有映射建立的页表就不用在内存中，所以省空间

### 页目录 页目录项 页表 页表项

页目录里面是页目录项，一个页目录项指向一个页表，页表里面是页表项，一个页表项指向一个物理页

![image-20230125153805674](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230125153805674.png)

需要了解的字段：

- P，present,1表示该页存在物理内存中，反之为0
- R/W，为0表示只可读，为1表示可读可写
- U/S，为1表示处于用户级，任意特权级别都能访问，为0表示处于超级用户级别，只有0,1,2能够访问，用户级别不能访问
- A，意为访问位，CPU访问过后该位置1，可以利用该位记录某一内存页的使用频率(操作系统定期清零，统计一段时间变为1的次数),如此可作为页面置换算法的依据
- D，脏位，CPU对某个页面进行写操作后置1，只对页表项有效，不会修改页目录的D位
- PS，页目录项特有，为0表示一个页面大小4KB，为1表示一个页面大小4M



### 开启分页机制

开启分页机制分为三步：

- 构建页表
- 加载页目录地址到CR3寄存器
- 设置CR0寄存器的PG位为1表示开启分页机制

注：CR3里面一定存放的是物理地址，CR3本身就是用来定位页目录表好做页级地址转换用的，如果CR3里面存放线性地址，寻找页目录还需要转缓地址，谁来转换？没有，所以CR3里面一定要存放页目录的物理地址



## 地址转换

![image-20230125160624780](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230125160624780.png)

地址转换分为两个步骤：

- 段级转换

  - 根据段选择子去GDT中寻找段描述符从中获取段基址
  - 段基址加上段内偏移量就是线性地址

- 页级转换

  - 根据线性地址的高10位去页目录中寻找相应页目录项，取页表物理地址
  - 根据线性地址的中10位去页表中寻找页表项，取物理页地址
  - 物理页基址加上线性地址中的后12位得到目标物理地址

  注：地址转换过程中有一些缓存来提高地址转换的速度，比如段描述符缓冲寄存器(对程序员不可见),快表TLB，TLB中的条目是虚拟地址的高20位到物理地址高20位的映射结果，实际上就是从虚拟页框到物理页框的映射，还有一些属性位，比如页表项的RW属性

  ![image-20230125161804707](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230125161804707.png)

## 平坦模式

分段模式，采用段基址(选择子):段内偏移的形式来访问内存其实是件很麻烦的事，访问不同的段还需要更换段寄存器里面的选择子，因为段基址不同，对于我们平时编程也有不小的挑战，所以就想了个办法规避开分段，于是就有了平坦模式

- 共用选择子也就是共用描述符
- 描述符的段基址设为0，界限设为4G-1

段描述符用来描述一个段，描述符其实描述了一个段的两个方面：位置和属性，现在平坦模式将起始位置设为0，段界限设为了4G，所以描述符位置这个作用就不大了，也就是说平坦模式下描述符的作用就是来说明一个段的属性

关于段的属性，很多段之间的属性是一样的，比如不同进程在用户态下的代码段，用户态下的数据段，还有TSS段，以及对于所有进程来说，虚拟地址空间的内核部分本身就是相同的，所以还有内核代码段，内核数据段

在平坦模式下，段基址(选择子):段内偏移的访问策略就不是很明显了。因为段基址都是0，真正有效的就是段内偏移量，我们平时编程使用的指针之类的，就是这个东西

需要注意的是分段的限制不是说没有分段了，再次强调分段是必须的，使用分段来将相同类型的数据集合在一起，加以段级的保护是计算机法制社会的重要特征

## 页面大小扩展

将CR4寄存器的RSE位置1，以及设置页目录项的PS位，便可以设置每页的大小为4M

如果是开启页面大小扩展，有点类似于一级页表，它是将虚拟地址的高10位作为页表的索引，得到页框的物理地址，假设低22位的偏移得到最终目标的物理地址

![image-20230125164305499](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230125164305499.png)

## ELF文件格式

ELF指的是可执行可链接格式，从命名上也可以看出它有两种试图：执行和链接两种视图

![image-20230125164551698](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230125164551698.png)

![image-20230125164652636](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230125164652636.png)

文件头的意义在于让程序的加载地址不那么固定，最简单的办法就是在程序文件中腾出个空间来写入这些程序的入口地址，跳转过去就行，当然不仅仅只写入程序入口地址，能写的东西很多，比如为了给程序分配内存，至少还得需要知道程序的尺寸大小，在哪写入程序的入口地址？这便是文件头的由来，在程序文件的开头部分记载这类信息，而程序文件中除文件头外其余的部分则是之前的程序体，这样一来，原先的纯二进制可执行文件加上新的文件头，就形成了一种文件格式

![image-20230126110136348](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126110136348.png)

可重定位目标文件和可执行目标文件就分别对应着ELF格式文件的链接视图和执行视图

![image-20230126110705826](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126110705826.png)

实际的ELF文件里面的节和段很多，这里只列出了比较重要需要了解的部分，下面以链接视图简要说明一下：

- .text:代码部分
- .rodata:只读的数据，例如printf中的格式串,switch-case中的跳转表
- .data:已初始化的全局变量和局部静态变量
- .bss:未初始化的全局变量和局部静态变量
- .symtab:symbol table,符号表，程序里面的全局变量名和函数名都属于符号，这些符号信息保存在符号表
- .rel.text：与可重定位相关的信息
- .debug,调试所用的符号表
- .init,包含可执行的指令，进程初始化代码的一部分，要在执行main函数之前执行这些代码

## 启动流程简要介绍

计算机的启动过程好比一场接力赛，BIOS，MBR，loader，OS，一个程序接一个程序的运行，而传递的接力棒便相当于对计算机的控制权

启动分为两种，一种为冷启动，是指计算机在关机状态下按POWER键启动，又叫硬件启动，比如开机，这种启动方式在启动之前计算机处于断电状态，像内存这种需要加电维持的存储部件里面的内容都丢失了，加电开机那一刻里面的值都是随机的，操作喜悦会对其进行初始化

而热启动是在加电的情况下启动，又叫软件启动，比如重启，这种启动方式在启动之前和启动之后电没斷过，内存等存储部件里面的值不会改变，但毕竟是启动过程，操作系统会对其进行初始化

### BIOS

启动的第一步便是运行BIOS程序，平常要运行某个程序一般分为两步：

- 将程序加载到内存
- 使CS：IP指向程序入口地址

而BIOS作为开机运行的第一个程序，运行方式与普通程序稍稍有所不同

- BIOS程序不需要谁来加载，本身便固定在ROM只读存储器中
- 开机的一瞬间CS:IP便被初始化为0xf000:0xfff0，开机的时候处于实模式，其等效地址为0xffff0

BIOS程序做了以下事情:

- POST自检，检验主板，内存，各类外设
- 对设备进行初始化
- 建立中断向量表，构建BIOS数据区，加载中断服务程序
- 权利交接给MBR

BIOS最后一项任务便是将加载启动盘最开始那个扇区里面的引导程序到0x7c00，然后跳去执行

### MBR

MBR主引导记录，它位于整个硬盘最开始的那个扇区分为三个部分

- 引导程序和一些参数，446字节
- 分区表DPT，64字节
- 结尾标记0X55和0XAA，2字节

### 分区表

分区表有4个表项，每个表项16字节，结构如下：

![image-20230126123553144](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126123553144.png)

这里主要关注活动分区标记，如果该分区表项的活动分区标记为0x80，说明该分区存在操作系统引导程序，MBR主要就是找到这么一个活动分区，将其中的操作系统引导程序加载到内存中，然后将接力棒交给它来执行

### loader

操作系统加载器，不论怎么叫，它的主要作用就是将操作系统加载到内存里面，操作系统也是一个程序，需要加载到内存里面才能运行，平常正在运行的计算机我们可以使用exec族函数来加载运行一个程序，同样的要加载运行操作系统这个程序就使用loader

### OSinit

操作系统内核加载到内存之后，就做一些初始化工作建立好工作环境，比如各个硬件的初始化，重新设置GDT,IDT，创建第一个init进程等等初始化的操作

## 硬盘相关知识

### 硬盘工作原理

![image-20230126153842644](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126153842644.png)

### 盘片盘面磁头

上图中光盘状的东西就是盘面，有两个面叫做盘面，上面分布着磁性介质，每个盘面都有个磁头，用来读写盘面上的数据

### 磁道扇区

![image-20230126155803067](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126155803067.png)

上图中灰色的圆环就是磁道，磁道上的绿色一段弧为扇区，扇区是磁盘读写的基本单位，通常为512字节

### 柱面

![image-20230126160144826](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126160144826.png)

每个磁盘由外向里从0编号，不同盘面上编号相同的磁盘组成的圆柱称为磁盘的柱面

机械式硬盘的寻道时间是整个硬盘的瓶颈，为了减少寻道时间，就尽量在存储上下功夫

如果待写入的数据小于一个磁道的剩余容量，将来再读出来的时候，磁道只定位到该磁道就行，这时候寻道只有一次，如果待写入的数据要占用多个磁道，需要多次寻道才能完成数据的完整读写

柱面中的磁道是相同编号，编号相同则意味着磁道在盘面上的位置相同，要定位到同一柱面中的磁道，所有磁头位置都一样，于是磁头不用再移动

按照这种想法写数据：当0面上的某磁道空间不足时，其他数据写入第1面相同编号的磁盘上，直到同一柱面上的磁盘(所有盘面上的编号相同的磁盘)都不够用时才会写到新的柱面上，所以，盘面越多，硬盘越快

### 硬盘控制器端口

![image-20230126162549067](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126162549067.png)

端口分为两组

Command Block registers和Control Block registers,Command Block registers用于向硬件驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers用于控制硬盘工作状态

端口是按照通道给出的，不要误以为端口是直接针对某块硬盘的，一个通道上的主,从两块硬盘都用这些端口号，要想操作某通道上的某块硬盘，需要单独指定，同时端口用途在读磁盘和写磁盘时还是有点区别

我们按照表逐一介绍寄存器的作用

### data寄存器

data寄存器它是负责管理数据的，在读磁盘的时候，磁盘准备好数据后，硬盘控制器将其放在内部的缓冲区中，不断读取寄存器便是读出缓冲区中全部的数据，在写磁盘的时候，我们把数据输怂到内部的缓冲区中，硬盘发现这个缓冲区有数据，便将此处的数据写入相应的扇区中

### error寄存器和feature寄存器

读硬盘时，端口0x171或0x1F1的寄存器叫Error寄存器，只在读取硬盘失败时有用，里面记录失败的信息，尚未读取的扇区数在Sector count寄存器中，在写磁盘时此寄存器有其他用处，所以有了新的名字叫Feature寄存器，有一些命令需要指定额外参数，这些参数就写在Feature寄存器中

### sector count寄存器

Sector count寄存器用来指定待读取或待写入的扇区数，硬盘每完成一个扇区，就会将寄存器的值减1，所以如果中间失败了，此寄存器中的值便是尚未完成的扇区，这是8位寄存器，最大值为255，若指定为0，则表示要操作256个扇区

### 磁盘的扇区定位

硬盘上的扇区在物理上是用柱面-磁头-扇区来定位的，简称CHS，每次都需要先算出扇区在哪个盘面，哪个柱面上，这个太麻烦了，我们希望得到一个对于人而言比较直观的办法，于是有了一种逻辑上为扇区编址的方法，称为逻辑块地址(LBA)，磁盘中扇区从0开始依次递增编号，不用考虑扇区所在的物理结构

### LBA

LBA有两种，一种是LBA28，用28位比特来描述一个扇区的地址，最大支持128GB，硬盘越来越大，得有相匹配的寻址方式与之配套，于是有了LBA48，用48位比特来描述一个扇区的地址，最大支持131072TB，本操作系统采用LBA28来实现

### LBA寄存器

LBA28有是三个寄存器(LBA low,LBA mid,LBA high)每一个都是8位宽度，三个8位寄存器不够LBA28，解决方法是采用device寄存器

### device寄存器

device寄存器是杂项，低4位用来存储LBA地址，第4位用来指定通道上的主盘或从盘，0表示主盘，1代表从盘，第6位用来设置是否启动LBA方式，1代表启动LBA模式，0代表启动CHS模式，其他位没用到就不关注了

### status寄存器

在读磁盘的时候，端口0x1f7或0x177的寄存器是Status，用来给出硬盘的状态信息

- 第0位表示ERR位，如果为1表示命令出错了
- 第3位是data requst位，如果为1，表示硬盘已经把数据准备好了
- 第6位是DRDY，表示硬盘就绪
- 第7位是BSY位，表示硬盘是否繁忙，如果为1表示硬盘正忙

### command寄存器

在写磁盘的时候，端口0x1F7或0x177的寄存器名称是command

主要使用三个命令

- identify:0xEC,即硬盘识别
- read sector:0x20,即读扇区
- write sector:0x30,即写扇区

### 常用的硬盘操作方法

- 先选择通道，往该通道的sector count寄存器中写入待操作的扇区数
- 往该通道上的三个LBA寄存器写入扇区起始地址的低24位
- 往device寄存器中写入LBA地址的24-27位，并置第6位为1，使其为LBA模式，设置第4位，选择操作的磁盘
- 往该通道上的command寄存器写入操作命令
- 读取该通道上的tatus寄存器，判断硬盘工作是否完成
- 如果以上步骤是读硬盘，进入下一个步骤，否则，完工
- 将硬盘数据读出

### 一般常用的数据传送方式

硬盘工作完成后，它已经准备好了数据，我们如何获取？一般常用的数据传送方式如下

- 无条件传送方式
  - 采用此方式一定是随时准备好了数据，CPU随时去随时拿都没有问题，如寄存器，内存

- 查询传送方式
  - 也称为程序I/O，是指传输之前，由程序先去检测设备的状态，数据源设备在一定条件下才能传送数据，这类设备通常是低速设备，设备状态为准备好了，CPU才会去获取数据，硬盘有status寄存器，所以对硬盘可以用此方式来获取数据
- 中断传送方式
  - 也称为中断驱动I/O，当数据源设备准备好数据后，它通过发中断来通知CPU来拿数据，这样避免了CPU花在查询上的时间

- 直接存储器存取方式(DMA)
  - DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输
  - 转移数据是可以不需要CPU参与，比如希望外设A的数据拷贝到外设B，只要给两种外设提供一条数据通路，直接让数据由A拷贝到B不经过CPU的处理
  - 采用中断的方式需要通知CPU，CPU需要通过压栈来保护现场，还要执行传输指令，最后还要恢复现场，而通过DMA控制器可以不让CPU参与传输，完全由数据源设备和内存直接传输，CPU直接到内存中拿数据就好了
- I/O处理机传送方式
  - 采用DMA方式，数据输入和输出之前还有一部分工作由CPU来完成，如数据交换，组合，校验等，为了解放CPU，再引入一个硬件，于是，I/O处理机诞生了，它其实是一种处理器，只不过用的是另一套擅长IO的指令系统，随时可以处理数据，有了I/O处理机的帮忙，CPU甚至可以不知道有传输这回事

## 处理器微架构简介

### 流水线

不管是CPU还是操作系统，都是人创造出来的东西，都脱离不开人的思维方式，我很喜欢将操作系统的设计带入到生活中，通过生活中的例子来理解操作系统的设计，比如特权级检查的RPL，我就会类比为身份证，它表示了一个人的身份，而RPL也代表了操作系统中访问者的身份，同样流水线也可以通过生活中的例子来理解

生活中充满并行的例子，比如人的身体，心脏在跳动，小肠在蠕动，他们的工作是彼此独立而且无关联的，人体内部的器官虽然是在并行工作，但是他们作为一个整体—人，却同一时刻只能做好一件事情，所以一心不能多用

CPU作为一个整体，在某一个时刻只能执行一个程序，但是CPU内部取指令，译码，执行是彼此独立的，可以在译码的时候去取下一条指令，但是作为整体，一次只能执行一个指令

CPU可以一边执行指令，一边取指令，一边译码，按照这三个步骤，其三级流水线如图所示

![image-20230127201953074](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230127201953074.png)

需要注意的是虽然一个时钟周期内CPU干了三件事，但是这三件事不属于同一个指令

CPU按照程序中指令顺序来填充流水线的，也就是按照程序计数器PC(cs:ip)中的值来装载流水线的

当前指令和下一条指令在空间上事挨着的，如果当前执行的指令是jmp，下一条指令已经被送上流水线译码了，而第三条指令已经被送上流水线取地址了，这个流水线是没有用的，所以CPU遇到jmp时，会清空流水线

## 启动代码部分

### RESET&&BIOS

启动时强制设置CS=0xf000,IP=0xfff0,这是BIOS程序入口点，入口点是一跳转指针jmp f000:e05b,然后开始执行BIOS的代码，内存低1M的顶部64KB都是分配给系统BIOS的，所以此时内存布局为：

![image-20230126125118141](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126125118141.png)

BIOS是一个只读的ROM区域，操作系统无能为力，一般是不能改动BIOS程序的，但是我们知道它的执行流程，从0xffff0开始执行BIOS的代码，然后将启动盘上的第0扇区(LBA寻址方式)也就是最开始那个扇区的MBR加载到0x7c00，然后开始执行，此时内存布局为：

![image-20230126125424507](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230126125424507.png)

### MBR

代码文件名字为mbr.S

```c
;主引导程序 
;------------------------------------------------------------
SECTION MBR vstart=0x7c00         
   mov ax,cs      
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00
```

第3行的"vstart=0x7c00"表示本程序在编译时，告诉编译器，把我的起始地址编译为0x7c00

第4-8行是对cs寄存器的值去初始化其他寄存器，由于BIOS是通过jmp 0:0x7c00跳转到MBR的，故cs此时为0，对于ds,es,fs,gs这类sreg,CPU中不呢直接给它们赋值，没有从立即数到段寄存器的电路实现

第9行是初始化栈指针

### 让MBR使用硬盘

本操作系统的MBR占据了硬盘的第0扇区(以LBA方式，扇区从0开始编号，若以物理CHS方式，扇区从1开始编号)，我们将loader放在第2扇区，并将加载地址选为0x900

```c
;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2
```

为了方便阅读，将会把用到的硬盘端口号和寄存器名称列在下方

![image-20230127153946932](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230127153946932.png)

rd_disk_16:

- 功能读取硬盘n个扇区

  ```c
  ;功能:读取硬盘n个扇区
  rd_disk_m_16:	   
  ;-------------------------------------------------------------------------------
  				       ; eax=LBA扇区号
  				       ; ebx=将数据写入的内存地址
  				       ; ecx=读入的扇区数
        mov esi,eax	  ;备份eax
        mov di,cx		  ;备份cx
  ```

- 第一步：设置要读取的扇区数

  ```c
    mov dx,0x1f2
        mov al,cl
        out dx,al            ;读取的扇区数
  
        mov eax,esi	   ;恢复ax
  ```

- 第二步：将LBA地址存入0x1f3 ~ 0x1f6

  ```c
    ;LBA地址7~0位写入端口0x1f3
        mov dx,0x1f3                       
        out dx,al                          
  
        ;LBA地址15~8位写入端口0x1f4
        mov cl,8
        shr eax,cl
        mov dx,0x1f4
        out dx,al
  
        ;LBA地址23~16位写入端口0x1f5
        shr eax,cl
        mov dx,0x1f5
        out dx,al
  
        shr eax,cl
        and al,0x0f	   ;lba第24~27位
        or al,0xe0	   ; 设置7～4位为1110,表示lba模式
        mov dx,0x1f6
        out dx,al
  ```

- 第3步：向0x1f7端口写入读命令，0x20 

  ```c
        mov dx,0x1f7
        mov al,0x20                        
        out dx,al
  ```

- 第4步：检查硬件状态

  ```c
   .not_ready:
        ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
        nop
        in al,dx
        and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
        cmp al,0x08
        jnz .not_ready	   ;若未准备好，继续等。
  ```

- ;第5步：从0x1f0端口读数据

  ```c
        mov ax, di
        mov dx, 256
        mul dx
        mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，
  			   ; 共需di*512/2次，所以di*256
        mov dx, 0x1f0
    .go_on_read:
        in ax,dx
        mov [bx],ax
        add bx,2		  
        loop .go_on_read
        ret
  ```

  ### 将控制权交给loader

  我们将loader放在第2扇区(LBA方式),MBR从第2扇区中把它读出来，然后放到内存地址为0x900的内存区域

  ```c
     mov eax,LOADER_START_SECTOR	 ; 起始扇区lba地址
     mov bx,LOADER_BASE_ADDR       ; 写入的地址
     mov cx,1			 ; 待读入的扇区数
     call rd_disk_m_16		 ; 以下读取程序的起始部分（一个扇区）
    
     jmp LOADER_BASE_ADDR
  ```

  ### 结尾标记

  结尾标记0x55和0xAA

  BIOS知道将MBR放在了第0扇区，如果此扇区末尾的两个字节分别为魔数0x55和0xaa，BIOS便认为此扇区中存在可执行程序

  ```c
     times 510-($-$$) db 0
     db 0x55,0xaa
  ```

  至此，MBR的任务就完成了，接力棒来到了下一个选手身上(loader)

## loader

loader要经过实模式到保护模式的过渡，并最终在保护模式下加载内核，我们先实现一个在实模式下工作的loader

```c
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
```

并将loader.bin写入磁盘第2个扇区

### 修改MBR读取的扇区数

loader.bin超过了512字节，目前它是1扇区，为了避免将来再次修改，我们直接读取4扇区

```c
mov cx,4          ;待读入的扇区数
call rd_disk_m_16 
```

### 修改boot.inc配置信息

为了方便查看，将会用到的格式列出来

![image-20230127165055549](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230127165055549.png)

段描述符的type类型

![image-20230127165515039](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230127165515039.png)

选择子的格式：

![image-20230127170251141](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230127170251141.png)

我们在boot.inc头文件中加入gdt描述符属性的宏定义和选择子属性的宏定义

```c
;-------------	 loader和kernel   ----------

LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2

;--------------   gdt描述符属性  -------------
DESC_G_4K   equ	  1_00000000000000000000000b   
DESC_D_32   equ	   1_0000000000000000000000b
DESC_L	    equ	    0_000000000000000000000b	;  64位代码标记，此处标记为0便可。
DESC_AVL    equ	     0_00000000000000000000b	;  cpu不用此位，暂置为0  
DESC_LIMIT_CODE2  equ 1111_0000000000000000b
DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2
DESC_LIMIT_VIDEO2  equ 0000_000000000000000b
DESC_P	    equ		  1_000000000000000b
DESC_DPL_0  equ		   00_0000000000000b
DESC_DPL_1  equ		   01_0000000000000b
DESC_DPL_2  equ		   10_0000000000000b
DESC_DPL_3  equ		   11_0000000000000b
DESC_S_CODE equ		     1_000000000000b
DESC_S_DATA equ	  DESC_S_CODE
DESC_S_sys  equ		     0_000000000000b
DESC_TYPE_CODE  equ	      1000_00000000b	\
;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  
DESC_TYPE_DATA  equ	      0010_00000000b	\
;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.

DESC_CODE_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 \
+ DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE\
+ DESC_TYPE_CODE + 0x00
DESC_DATA_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL \
+ DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL \
+ DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b

;--------------   选择子属性  ---------------
RPL0  equ   00b
RPL1  equ   01b
RPL2  equ   10b
RPL3  equ   11
TI_GDT	 equ   000b
TI_LDT	 equ   100b
```

### loader.S

接下来我们分析一下loader.S

#### 构建加载临时GDT

全局描述符表GDT只是一片内存区域，里面每隔8字节便是一个表项，即段描述符，我们将描述符拆成高4字节和低4字节，分别定义

```
;构建gdt及其内部的描述符
   GDT_BASE:   dd    0x00000000 
	       dd    0x00000000

   CODE_DESC:  dd    0x0000FFFF 
	       dd    DESC_CODE_HIGH4

   DATA_STACK_DESC:  dd    0x0000FFFF
		     dd    DESC_DATA_HIGH4

   VIDEO_DESC: dd    0x80000007	       ;limit=(0xbffff-0xb8000)/4k=0x7
	       dd    DESC_VIDEO_HIGH4  ; 此时dpl已改为0

   GDT_SIZE   equ   $ - GDT_BASE
   GDT_LIMIT   equ   GDT_SIZE -	1 
   times 60 dq 0					 ; 此处预留60个描述符的slot
   SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
   SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0	 ; 同上
   SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0	 ; 同上 

   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址

   gdt_ptr  dw  GDT_LIMIT 
	    dd  GDT_BASE
```

我们事先定义了3个有用的段描述符，需要注意的是第0个描述符没有用

同时需要说明的是DATA_STACK_DESC是数据段和栈段的段描述符，我们这里数据段和栈段共用一个段描述符

栈应该是向下扩展的，数据段是向上扩展的，一个段描述符只能定义一种扩展方向，段描述符的各名字段只是用来供CPU检查的，CPU不知道此段是用来干什么的，只有用此段的人才知道，栈段向下扩展，是指栈指针esp指向的地址逐渐减少，那个是push的作用，和段描述符的扩展方向无关，那个主要用来配合段界限使用，CPU在检查段内偏移地址的合法性时，就需要结合扩展方向和段界限来判断，而且用向上扩展的数据段做栈段，比用向下扩展的段更容易

#### 打开A20地址线

```c
   ;-----------------  打开A20  ----------------
   in al,0x92
   or al,0000_0010B
   out 0x92,al
```

#### 加载GDT

```c
   ;-----------------  加载GDT  ----------------
   lgdt [gdt_ptr]
```

#### cr0第0位置1

```
  ;-----------------  cr0第0位置1  ----------------
   mov eax, cr0
   or eax, 0x00000001
   mov cr0, eax
```

#### 刷新流水线

```c
jmp  SELECTOR_CODE:p_mode_start//刷新流水线，避免分支预测的影响，通过此方法可以使之前的预测失效
```

为什么要采用jmp远跳转

为了解决两件事情

- 段描述符缓冲寄存器还是实模式下的值，进入保护模式后还需要填入正确的信息
  - 段描述符缓冲寄存器在CPU的实模式和保护模式下都同时使用，在不引用新段的情况下，段描述符缓冲寄存器不会改变，而此时段描述符寄存器中的内容仅仅是实模式下的20位的段基址，很多属性位都是错误的，所以需要即使更新段描述符缓冲寄存器
- 流水线中指令译码错误
  - [bits 32]是让编译器编译器将此后的指令编译称为32位
  - 流水线会导致在执行16位指令的时候将32位的指令放上流水线，导致32位的指令被译码为16位的指令，从而出错，所以需要用jmp来清空流水线

#### 用选择子初始化各段寄存器

```c
[bits 32]
p_mode_start:
   mov ax, SELECTOR_DATA
   mov ds, ax
   mov es, ax
   mov ss, ax
   mov esp,LOADER_STACK_TOP
   mov ax, SELECTOR_VIDEO
   mov gs, ax
```

### 启动分页机制

启动分页机制需要完成三件事

- 准备好页目录表及页表
- 将页表地址写入控制寄存器cr3
- 寄存器cr0的PG位置1

#### 页目录基址寄存器

- 页表和描述符表一样，是个内存的数据结构，处理器要使用它们，必须要知道它们的物理地址

- 控制寄存器CR3用于存储页表的物理地址，结构如图所示：

  ![image-20230128131949996](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230128131949996.png)

####  创建页目录表和页表

创建页目录表和页表的函数为setup_page

- 先将页目录占用的空间逐字节清0

  ```c
  setup_page:
  ;先把页目录占用的空间逐字节清0
     mov ecx, 4096
     mov esi, 0
  .clear_page_dir:
     mov byte [PAGE_DIR_TABLE_POS + esi], 0
     inc esi
     loop .clear_page_dir
  ```

- 创建页目录项(PDE)

  为了方便查看PDE和PTE的结构，将结构图放在下方

  ![image-20230128134420727](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230128134420727.png)

  在boot.inc文件中添加页表相关属性和页目录表的物理地址

  ```c
  PAGE_DIR_TABLE_POS equ 0x100000
  ;----------------   页表相关属性    --------------
  PG_P  equ   1b
  PG_RW_R	 equ  00b 
  PG_RW_W	 equ  10b 
  PG_US_S	 equ  000b 
  PG_US_U	 equ  100b 
  ```

  我们将页目录表放置到物理内存0x100000

  我们接着分析create_pde

  ```c
  .create_pde:				     ; 创建Page Directory Entry
     mov eax, PAGE_DIR_TABLE_POS
     add eax, 0x1000 			     ; 此时eax为第一个页表的位置及属性
     mov ebx, eax				     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。
  ```

  页目录表的大小为4KB，我们将页目录表的基址加上页目录表的大小所得到的的地址作为第一个页表的位置,即0x101000

  接下来创建页目录项

  ```c
  ;   下面将页目录项0和0xc00都存为第一个页表的地址，
  ;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，
  ;   这是为将地址映射为内核地址做准备
     or eax, PG_US_U | PG_RW_W | PG_P	     /
     ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.
     mov [PAGE_DIR_TABLE_POS + 0x0], eax       /
     ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(7)
     mov [PAGE_DIR_TABLE_POS + 0xc00], eax     /
     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,
     ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.
     sub eax, 0x1000
     mov [PAGE_DIR_TABLE_POS + 4092], eax	     ; 使最后一个目录项指向页目录表自己的地址
  ```

  这里需要说明的是我们将第0项和第768项都指向了同一个页表，原因是程序中运行的一直都是loader,它本身的代码都是在1MB之内，必须保证之前段机制下的线性地址和分页后的虚拟地址对应的物理地址一致，第0个页目录项代表的页表，它表示的空间是0—0x3fffff,所以用了第0项来保证loader在分页机制下依然运行正常，我们将来会将操作系统内核放在低端1M物理内存空间，但是操作系统的虚拟地址是0xc0000000以上，该虚拟地址对应的页目录项是第768个，这样虚拟地址0xc0000000—0xc03fffff之间的内存都指向的是低端4MB之内的物理地址

- 创建页表项(PTE)

  ```c
     mov ecx, 256				     ; 1M低端内存 / 每页大小4k = 256
     mov esi, 0
     mov edx, PG_US_U | PG_RW_W | PG_P	     ; 属性为7,US=1,RW=1,P=1
  .create_pte:				     ; 创建Page Table Entry
     mov [ebx+esi*4],edx			     /
      ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 
     add edx,4096
     inc esi
     loop .create_pte
  ```

  此页表是页目录表中第0个页目录项所对应的页表，它用来分配物理地址范围0—0x3fffff之间的物理页,这也是虚拟地址0x0—0x3fffff和虚拟地址0xc0000000—0xc03fffff对应的物理页，我们目前只用到了第1MB空间，而每个物理页是4KB，所以只需要256个页表项

- 创建内核其他页表的PDE

  ```c
     mov eax, PAGE_DIR_TABLE_POS
     add eax, 0x2000 		     ; 此时eax为第二个页表的位置
     or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性US,RW和P位都为1
     mov ebx, PAGE_DIR_TABLE_POS
     mov ecx, 254			     ; 范围为第769~1022的所有目录项数量
     mov esi, 769
  .create_kernel_pde:
     mov [ebx+esi*4], eax
     inc esi
     add eax, 0x1000
     loop .create_kernel_pde
     ret
  ```

  我们创建了除第768个页表外的其他页表对应的PDE，为了真正实现内核被所有进程共享，为内核额外安装了254个页表的PDE(第255个PDE已经指向了页目录表本身)，也就是内核空间的实际大小为1GB减去4MB的差，需要注意的是此处只是将页目录表中的内核部分的页目录项进行赋值，必须要为页表中具体的PTE分配物理页框之后才算真正的内存地址

  

#### 更改全局描述符表地址

之前我们是在实模式下创建的GDT，此时进入到了保护模式，此时所有的地址都是虚拟地址,我们将GDT存放在内核内存地址空间，所以此时需要将GDT的虚拟地址设置为内核地址空间的虚拟地址

需要注意的是：

- cr3里保存页目录表的基址的地址类型为物理地址，页目录表里的每一项也是页表的物理地址
- GDTR里面保存的地址类型为线性地址

```c
   ;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载
   sgdt [gdt_ptr]	      ; 存储到原来gdt所有的位置

   ;将gdt描述符中视频段描述符中的段基址+0xc0000000
   mov ebx, [gdt_ptr + 2]  
   or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。
					      ;段描述符的高4字节的最高位是段基址的31~24位

   ;将gdt的基址加上0xc0000000使其成为内核所在的高地址
   add dword [gdt_ptr + 2], 0xc0000000

   add esp, 0xc0000000        ; 将栈指针同样映射到内核地址
```

#### 把页目录地址赋值给CR3

```c
   mov eax, PAGE_DIR_TABLE_POS
   mov cr3, eax
```

#### 打开cr0的pg位(第31位)

```c
   mov eax, cr0
   or eax, 0x80000000
   mov cr0, eax
```

#### 打开分页后,用gdt新的地址重新加载

```c
lgdt [gdt_ptr]             ; 重新加载
```

### 用虚拟地址访问页表

页表是一种动态的数据结构，我们在申请一块内存的时候，我们需要添加页目录项或者页表项，如果释放内存的时候，我们需要将页表中相应的页表项或页目录项都要清0，这也是二级页表灵活的地方，根据需要动态增减

页表存放在内存中，但在分页机制下，我们需要通过虚拟地址访问页表本身

我们采用了将页目录表的最后一个页目录项中填入了页目录表的物理地址

```c
mov [PAGE_DIR_TABLE_POS+4092]，eax
```

用虚拟地址获取表中各数据类型的方法

- 获取页目录表物理地址：让虚拟地址的高20位为0xfffff，低12位为0x000，即0xfffff000,这也是页目录表中第0个页目录项自身的物理地址
- 访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为0xfffffxxx，其中xxx是页目录项的索引乘以4的积
- 访问页表中的页表项：要使虚拟地址高10位为0x3ff，目的是获取页目录表物理地址，中间10位为页表的索引，因为是10位的索引值，所以这里不用乘以4，低12位为页表内的偏移地址，用来定位页表项，它必须是已经乘以4后的值

#### 将内核载入内存

我们的内核文件是kernel.bin，这个文件是由loader将其从磁盘上读出并加载到内存中的，到此，接力棒传入到了最后一个选手的手里

我们将MBR写在了硬盘的第0扇区，将loader写在磁盘的第2扇区，将kernel.bin放在第9个扇区

### kernel.bin

我们先写第一个内核程序main.c

```c
int main(void){
	while(1);
    return 0;
}
```

在Linux下用于链接的程序是ld，链接有一个好处，可以指定最终生成的可执行文件的起始虚拟地址，我们将main指定虚拟地址为0xc0001500

```c
//用-Ttext指定起始虚拟地址
```

#### 入口地址

一个程序需要有入口地址，这个地址表示的是程序将从哪里开始执行，我们知道程序体的第一个字节并不一定是程序的起始地址，因为里面可能有函数声明或数据定义，我们在设计loader.S的时候，知道它的入口地址不在程序开始处，所以在mbr中直接跳入了loader_start标号处

```c
 jmp LOADER_BASE_ADDR + 0x300
```

如果多个文件拼合成一个可执行文件时，这入口地址就说不准是哪一个了

由于程序内的地址是在链接阶段编排(重定位)，所以在链接阶段必须要明确入口地址，于是链接器规定，默认只把名为_start的函数作为程序的入口地址

如果我们直接使用gcc main.c 而不是经过手动编译和链接两个步骤完成，此时文件大小会比我们手动编译和链接的文件更大，原因在于C运行库，目的是在调用main函数前做初始化环境等工作，这也说明了main函数不是第一个执行的代码，它一定是被其他代码调用的

#### 加载内核

我们的内核是由loader加载的，所以我们需要修改一下loader.S

需要修改两个地方

- 加载内核：需要把内核文件加载到内核缓冲区
- 初始化内核，需要在分页后，将加载进来的elf内核文件安置到相应的虚拟内存地址，然后跳过去执行、

第一步加载内核，我们只是把内核从硬盘上拷贝到内存中，不是运行内核代码，这项工作在开启分页前后都可以，我们把它安排在分页之前加载

#### 设置缓冲区

内核加载到内存中，得有个加载地址，也就是缓冲区

- 缓冲区(buffer)，意味存放物品的地方，也就是加工处理中暂存数据的地方

参考目前内存中哪些地方还有可用的空间

![image-20230130172407102](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230130172407102.png)

内核被加载到内存后，loader还要通过分析其elf结构将其展开到新的位置，所以说，内核在内存中有两份拷贝，一份是elf格式的源文件kernel.bin，另一份是loader解析elf格式的kernel.bin后在内存中生成的内核映射(也就是将程序中的各种段复制到内存后的程序体)，这个映像才是真正运行的内核

我们将内核的缓冲区放在0x70000

```c
; -------------------------   加载kernel  ----------------------
   mov eax, KERNEL_START_SECTOR        ; kernel.bin所在的扇区号
   mov ebx, KERNEL_BIN_BASE_ADDR       ; 从磁盘读出后，写入到ebx指定的地址
   mov ecx, 200			       ; 读入的扇区数

   call rd_disk_m_32

   ; 创建页目录及页表并初始化页内存位图
   call setup_page
```

内核文件的地址是编译阶段确定的，里面都虚拟地址，程序也是靠这些虚拟地址来运行的，我们需要在物理低端1MB内存中，找一个空间来存放内核映射，于是我们将内核的入口虚拟地址放在0xc0001500，之前我们设置了页表，将低端1MB的虚拟内存与物理内存一一对应，所以物理地址是0x1500，对应好的虚拟地址是0xc0001500

#### 将kernel.bin中的segment拷贝到编译的地址

我们将elf文件格式放在此处

ELF header结构

![image-20230130184228783](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230130184228783.png)

列出在代码中会用到的成员

- e_phentsize:用来指明程序头表中每个条目的字节大小，即每个用来描述段信息的数据结构的字节大小
- e_phoff，用来指明程序头表在文件内的字节偏移量
- e_phnum，用来指明程序头表中条目的数量，实际上就是段的个数



程序头表中的条目的数据结构

![image-20230130191549026](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230130191549026.png)

列出需要使用的成员

- p_type:用来指明程序中该段的类型

  ![image-20230130191818890](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230130191818890.png)

- p_filesze用来指明本段在文件中的大小
- p_offset，用来指明本段在文件内的起始偏移字节
- p_vaddr，用来指明本段在内存中的起始虚拟地址

kernel_init的原理是分析程序中的每个段，如果段类型不是PT_NULL(空程序类型)，就将该段拷贝到编译的地址中

```c
;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------
kernel_init:
   xor eax, eax
   xor ebx, ebx		;ebx记录程序头表地址
   xor ecx, ecx		;cx记录程序头表中的program header数量
   xor edx, edx		;dx 记录program header尺寸,即e_phentsize

   mov dx, [KERNEL_BIN_BASE_ADDR + 42]	  /
       ; 偏移文件42字节处的属性是e_phentsize,表示program header大小
   mov ebx, [KERNEL_BIN_BASE_ADDR + 28]   /
           ; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量
					  ; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值
   add ebx, KERNEL_BIN_BASE_ADDR
   mov cx, [KERNEL_BIN_BASE_ADDR + 44]    /
                          ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header
.each_segment:
   cmp byte [ebx + 0], PT_NULL		  ; 若p_type等于 PT_NULL,说明此program header未使用。
   je .PTNULL

   ;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)
   push dword [ebx + 16]		  /
       ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size
   mov eax, [ebx + 4]			  ; 距程序头偏移量为4字节的位置是p_offset
   add eax, KERNEL_BIN_BASE_ADDR	  ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址
   push eax				  ; 压入函数memcpy的第二个参数:源地址
   push dword [ebx + 8]			  /
       ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址
   call mem_cpy				  ; 调用mem_cpy完成段复制
   add esp,12				  ; 清理栈中压入的三个参数
.PTNULL:
   add ebx, edx				  ; edx为program header大小,即e_phentsize,在此ebx指向下一个program header 
   loop .each_segment
   ret
```

此段代码的内存布局为：

![image-20230130203601808](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230130203601808.png)

#### 搬运指令三剑客

字符串搬运指令族：movsb,movsw,movsd

- movsb是搬运1字节
- movsw是搬运2字节
- movsd是搬运4字节

rep指令是按照ecx寄存器中指定的次数重复执行后面的指定的指令，每执行一次，ecx自减1

cld(clean direction)指令是将eflags寄存器中的方向标志位DF置为0，si和di根据使用的字符串指令自动加上所搬运数据的字节大小

std是(set direction)，该指令是将方向标志位DF置为1，这样每次搬运的时候，si和di自动减去所搬运数据的字节大小

需要注意是从低地址到高地址，DF标志为0

mem_cpy的实现：

```c
mem_cpy:		      
   cld
   push ebp
   mov ebp, esp
   push ecx		   ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份
   mov edi, [ebp + 8]	   ; dst
   mov esi, [ebp + 12]	   ; src
   mov ecx, [ebp + 16]	   ; size
   rep movsb		   ; 逐字节拷贝

   ;恢复环境
   pop ecx		
   pop ebp
   ret
```

进入内核之后，我们用的栈需要重新规划，栈起始地址不能再用0xc0000900，我们将esp改为0xc009f000

此时的内存布局为：

![image-20230130210204283](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230130210204283.png)

```c
   call kernel_init
   mov esp, 0xc009f000
   jmp KERNEL_ENTRY_POINT                 ; 用地址0x1500访问测试，结果ok
```



## 中断理论部分

### 外部中断

外部中断是指CPU外部的中断，而外部的中断源必须是某个硬件，所以外部中断又称为硬件中断

CPU为大家提供了两条信号线，外部硬件的中断是通过两根信号线通知CPU的，这两根信号线是INTR和NMI

![image-20230131171115535](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230131171115535.png)

外部中断又可以分为可屏蔽中断和不可屏蔽中断

- 可屏蔽中断：通过INTR引脚进入CPU的，可以使用eflags寄存器的IF位将所有外部设备的中断屏蔽

  - 上半部和下半部

    将中断处理程序分为上半部和下半部，把中断处理程序中需要立即执行的部分划分到上半部，这部分是要限时完成的，而中断处理程序中那些不紧急的部分则被推迟到下半部去完成

    中断处理程序的上半部是刻不容缓的，所以上半部是在关中断不被打扰的情况下执行的

    当上半部执行完成后就把中断打开，中断处理程序下半部则是在开中断的情况下执行

    以网卡为例子

    网络中的数据通过网线到达网卡后，首先会存储在网卡自己的缓冲区中，这个缓冲区不大，必须要及时的将CPU的数据拿走，所以CPU在得知网卡数据到来的时候，将当前的事情·放下，转去执行网卡的中断处理程序，将网卡缓冲区的数据拷贝到内核缓冲区，而处理这些数据就可以在适当时机的时候进行处理

- 不可屏蔽中断

  一般是致命问题

### 内部中断

内部中断可以分为软中断和异常

- 软中断：由软件主动发起的中断，由于该中断软件运行中主动发起的，所以它是主观上的，并不是客观上的某种内部错误
  - 系统调用
  - 软中断也无视IF位
- 异常：是指令在执行期间CPU内部产生的错误引起的
  - 由于是运行是错误，所以不受标志寄存器eflags中的IF位影响
  - 比如分母为0

### 中断描述符表

中断描述符表(IDT)是保护模式下用于存储中断处理程序入口的表，当CPU接收到一个中断时，需要用中断向量在此表中检索对应的描述符，在该描述符中找到中断处理程序的起始地址，然后执行中断处理程序

IDT中只有称为门的描述符，段描述符中描述的是一片内存区域，而门描述符中描述的是一段代码

描述符高4字节的第8-12位(type)是固定的意义，用来表述描述符的类型，第12位是S位，用来表示系统段或非系统段

因为linux的系统调用是通过中断门实现的，所以我们只研究中断门结构

![image-20230201181806652](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230201181806652.png)

中断门包含了中断处理程序所在段选择子和段内偏移地址,当通过此方式进入中断后,标志寄存器eflags的IF位自动置0,避免中断嵌套,linux就是利用中断门实现的系统调用,中断门只允许存在于IDT中

对比中断向量表,中断描述符有两个区别

- 中断描述符表地址不限制,在哪里都可以
- 中断描述符表中的每一个描述符用8字节描述

中断描述符表的基址保存在中断描述符表寄存器(IDTR)

![image-20230201182718284](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230201182718284.png)

需要注意的是处理器只支持256个中断，而中断描述符表可以容纳描述符的个数为64KB/8=8K

### 中断处理过程及保护

完整的中断过程分为CPU外和CPU内两部分

- CPU外：外部设备的中断由中断代理芯片接收,处理后将该中断的中断向量号发送到CPU
- CPU内：CPU执行该中断向量号对应的中断处理程序
  - 处理器根据中断向量号定位中断门描述符
  - 处理器进行特权级检测
    - 中断向量号只是个整数,其中并没有RPL,
    - 如果是由软中断int n,int3和into引发的中断,这些是用户进程中主动发起的中断,由用户代码控制,处理器要检测当前特权级CPL和门描述符DPL,如果CPL权限大于等于DPL,即数值上CPL<=门描述符DPL,特权级门槛检测通过进入下一步的"门框"检查,否则,处理器抛出异常
    - 门框检测：处理器要检查当前特权级CPL和门描述符中所记录的选择子对应的目标代码段DPL,如果CPL权限小于目标代码段DPL,检测通过，也就是说除了用返回指令从高特权级返回，特权转移只能发生在由低向高
    - 若中断是由外部设备和异常引起的，只直接检测CPL和目标代码段的DPL
  - 执行中断处理程序
    - 特权级检查通过后,将门描述符目标代码段选择子加载到代码寄存器CS中,把门描述符中断处理程序的偏移地址加载到EIP,开始执行中断处理程序

中断发生后,eflags中的NT位和TF位会被置0，如果中断对应的门描述符是中断门，标志寄存器eflags中的IF位被自动置0，避免中断嵌套

- TF位：表示Trap Flag,也就是陷阱标志位,当TF为0时表示禁止单步执行,也就是说不允许中断处理程序单步执行

- NT位：即任务嵌套标志位，任务嵌套调用是指CPU将当前正执行的旧任务挂起,转去执行另外的新任务,待新任务执行完后,CPU再回到旧任务继续执行

  CPU执行新任务之前，CPU做了两件准备工作

  - 将旧任务TSS选择子写到了新任务TSS中的“上一个任务TSS的指针”字段中
  - 将新任务标志寄存器eflags中的NT位置1，表示新任务之所以能够执行，是因为有别的任务调用了它

  当CPU执行iret时,它会去检查NT位的值，如果NT位为1，这说明当前任务是被嵌套执行的，因此会从自己TSS中的"上一个任务TSS的指针"字段中获取旧任务，然后去执行该任务，如果NT位的值为0，表示当前是在中断处理环境下，于是就执行正常的中断退出流程

中断处理过程：

![image-20230208134149391](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208134149391.png)

### 中断发生时的压栈

首先我们只讨论32位保护环境下的中断情况

中断在发生时,段寄存器会被加载,段描述符缓冲寄存器会被刷新,处理器都认为是换了一个段,属于远跳转,所以当前进程被打断后,为了从中断返回后能继续运行该进程,处理器自动把CS和EIP的当前值保存到中断处理程序使用的栈中,不同特权级别下处理器使用不同的栈,除了要保存CS,EIP外,还需要保存标志寄存器EFLAGS,如果涉及到特权级变化,还要压入SS和ESP寄存器

有特权级变换的栈中数据：

- 处理器根据中断向量号找到对应的中断描述符后,拿CPL和中断描述符选择子对应的目标代码段的DPL对比,若CPL权限比DPL低,这表示要向高特权级转移,需要切换到高特权级的栈，于是处理器先临时保存当前旧栈SS和ESP的值，记作SS_old和ESP_old，然后在TSS中找到同目标代码段DPL级别相同的栈加载到寄存器SS和ESP中，记作SS_new和ESP_new，再将之前临时保存的SS_old和ESP_old压入新栈备份，以备返回时重新加载到栈段寄存器SS和栈指针ESP，此时新栈内容如图所示

  ![image-20230208150619562](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208150619562.png)

- 在新栈中压入EFLAGS寄存器，新栈内容如图所示

  ![image-20230208150727344](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208150727344.png)

- 由于要切换到目标代码段，对于这种段间转移,要将CS和EIP保存到当前栈中备份,记作CS_old和EIP_old,以便中断程序执行结束后能恢复到被中断的进程，当前栈是新栈,还是旧栈，取决于第一步是否涉及到特权级转移

  ![image-20230208151105946](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208151105946.png)

- 某些异常会有错误码,此错误用于报告异常是在哪个段上发生的,也就是异常发生的位置，所以错误码中包含选择子等信息，错误码会紧跟在EIP之后入栈，记作ERROR_CODE,此时新栈内容如图所示

  ![image-20230208151319246](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208151319246.png)

无特权级变化时栈中数据：

![image-20230208151449193](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208151449193.png)

处理器进入中断执行完中断处理程序后,还要返回到被中断的进程，这是进入中断的逆过程，中断返回是用iret指令

处理器并不知道进入中断已经做过了特权级检查,所以为了安全起见,处理器在返回到被中断过程中也要再进行一次特权级检查，我们现在考虑一下返回时的特权级检查，假设此时已经手动将ERROR_CODE从栈中弹出,栈顶已位于正确的位置,即指向EIP_old

- 当处理器执行到iret指令时,它知道要执行远返回，首先需要从栈中返回被中断进程的代码段选择子CS_old及指令指针EIP_old，这时候它要进行特权级检查，先检查栈中CS选择子CS_old，根据RPL位,即未来的CPL，判断在返回过程中是否要改变特权级
- 栈中CS选择子是CS_old，根据CS_old对应的代码段的DPL及CS_old中的RPL做特权级检查,如果检查通过，随即更新寄存器CS和EIP，将CS_old低16位加载到CS,将EIP_old加载到EIP寄存器，之后栈指针指向EFLAGS，如果进入中断时未涉及特权级转换，此时栈指针是ESP_old，否则栈指针是ESP_new
- 将栈中保存的EFLAGS弹出到标志寄存器EFLAGS，如果在第一步中判断返回后要改变特权级，此时栈指针是ESP_new，它指向栈中的ESP_old，否则进入中断时属于平级转移，用的是旧栈，此时栈指针是ESP_old，栈指针指向中断发生前的栈顶
- 如果在第一步中判断出返回时需要改变特权级，也就是说需要恢复旧栈，此时便需要将ESP_old和SS_old分别加载到寄存器ESP及SS，丢弃寄存器SS和ESP中原有的SS_new和ESP_new

需要注意的是如果在返回时需要改变特权级,将会检查数据段寄存器DS,ES,FS和GS的内容,如果在它们之中,某个寄存器中选择子所指向的数据段描述符的DPL权限比返回后的CPL(CS.RPL)高,处理器会将数值0填充到相应的段寄存器中，从而故意使处理器抛出异常

### 中断错误码

有些中断会在栈中压入错误码，用来指明中断发生在哪个段上,所以,错误码最主要的部分就是选择子

格式如图所示：

![image-20230208161620885](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208161620885.png)

- EXT：用来指明中断源是否来自处理器外部,如果中断源是不可屏蔽中断或外部设备,EXT为1，否则为0
- IDT：表示选择子是否指向中断描述符IDT，IDT位为1，则表示此选择子指向中断描述符表，否则指向全局描述符表GDT或局部描述符表LDT
- TI：为0用来指明选择子从GDT中检索描述符，为1时是从LDT中索引描述符

### 可编程中断控制器8259A

8259A的作用是负责所有来自外设的中断,其中就包括来自时钟的中断

8259A用于管理和控制可屏蔽中断,它表现在屏蔽外设中断，对它们实行优先级判决，向CPU提供中断向量号等功能

intel处理器共支持256个中断,但8259A只可以管理8个中断,为了多支持一些中断设备，于是将多个8259A组合，官方术语就是级联，有了级联这种组合后,每一个8259A就被称为1片，若采用级联方式，即多片8259A芯片串连在一起，最多可级联9个,最多可支持64个中断，n片8259A通过级联可支持7n+1个中断源，来自从片的中断只能传递给主片，再由主片向上传递给CPU，也就是只有主片才能向CPU发送INT中断信号

每个独立的外部设备都是一个中断源，它们所发出的中断，只有接在中断请求(IRQ)信号线上才能被CPU知晓,

8259A主片和从片关系如图所示

![image-20230208165740717](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208165740717.png)

8259A的内部结构如图所示

![image-20230208170105940](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230208170105940.png)

- INT：8259A选出优先级最高的中断请求后,发信号通知CPU
- INTA：中断响应信号
- IMR： 中断屏蔽寄存器,宽度是8位,用来屏蔽某个外设的中断
- IRR： 中断请求寄存器，相当于5259A维护的未处理中断信号队列
- PR：优先级仲裁器，当有多个中断同时发生，或当有新的中断请求进来时，将它与当前正在处理的中断进行比较，找到优先级更高的中断
- ISR：中断服务寄存器，当某个中断正在被处理时，保存在此寄存器中

以上介绍的寄存器都是8位，其原因是8259A共8个IRQ接口，可以用8位寄存器中的每一位代表8259A的每个IRQ接口，类似于接口的位图，操作寄存器中的位便表示处理来自对应的IRQ接口的中断信号

现在我们来思考一下8259A的工作流程

- 当某个外设发出一个中断信号时，主板上已经将信号通路指向了8259A芯片的某个IRQ接口
- 8259A首先检测IMR寄存器中是否已经屏蔽了来自该IRQ接口的中断信号，如果IMR寄存器中的位为1，则表示中断屏蔽，否则将其送入IRR寄存器
- 当某个恰当时机，优先级仲裁器PR会从IRR寄存器中挑选一个优先级最大的中断，优先级判断标准很简单，就是IRQ接口号越低，优先级越大，所以IRQ0优先级最大
- 8259A会在控制电路中，通过INT接口向CPU发送INTR信号，信号被送入CPU的INTR接口后，这样CPU便知道有新的中断到来了，于是CPU将当前的指令执行完后，马上通过自己的INTA接口向8259A的INTA接口回复一个中断响应信号
- 8259A在收到了CPU发送的INTA信号后，将刚才选出的优先级最大的中断在ISR寄存器中对应的位置1，此寄存器表示正在处理的中断，同时将该中断在IRR中去掉，也就是将IRR中将该中断对应的位置0
- CPU将再次发送INTA信号给8259A，这次是想获取中断对应的中断向量号，8259A用起始中断向量号+IRQ接口号便是该设备的中断向量号
- 8259A将此中断向量号通过系统数据总线发送给CPU，CPU从数据总线上拿到该中断向量号后，用它做中断向量号表或中断描述符表中的索引，找到相应的中断处理程序并去执行
- 如果8259A的EOI通知被设置为非自动模式，中断描述符程序结束处必须向8259A发送EOI的代码，8259A在收到EOI后，将当前正处理的中断在ISR寄存器中对应的位置0，如果EOI通知被设置为自动模式，在刚才8259A接收到第二个INTA信号后，CPU向8259A要中断向量号的那个INTA，8259A会自动将此中断在ISR中对应的位置0

并不是进入ISR后的中断就高枕无忧等着见CPU了。它还是有可能被后者换下来的，比如，在8259A发送中断向量号给CPU之前，这时候又来了新的中断，如果它的来源IRQ接口号比ISR中的低，原来ISR中准备上CPU处理的旧中断，其对应的BIT就得清0，同时将它所在的IRR中的相应位恢复为1，随后在ISR中将此优先级更高的新中断对应的位置1，然后将此新中断的中断向量号发给CPU

软件的舞台要靠硬件的支撑，为开发方便，很多功能都是由硬件原生支持的，因此，CPU也提供了中断处理的框架，在此框架中，我们只要填入所需要的数据即可，其他的工作由CPU自动运作，和中断处理相关的数据结构是中断描述符表和中断向量号

以上说的是中断处理框架的流程，我们要做的很简单

- 构建IDT
- 提供中断向量号

外部设备不知道中断向量号，它只负责中断信号，中断向量号是8259A传送给CPU的，而8259A是由我们控制的，中断描述符表也是我们构造的，我们需要为外部设备设置好中断向量号，然后自己在中断描述符表中的对应项添加好合适的中断处理程序

### 8259A的编程

我们通过编程把它设置成需要的样子，对它的编程也很简单，就是对它进行初始化，设置主片与从片的级联，指定起始向量号以及设置各种工作模式

在开机之后的实模式下，BIOS也对它光顾过，8259A的IRQ0-7已经被BIOS分配了0x8-0xf的中断向量号

中断向量号是逻辑上的东西，它在物理上是8259A上的IRQ接口号，8259A上IRQ的排列顺序是固定的,但其对应的中断向量号是不固定的，这其实是一种由硬件到软件的映射，同属设置8259A，可以将IRQ接口映射到不同的中断向量号

在8259A内部有两组寄存器，一组是初始化命令寄存器组，用来保存初始化命令字，ICW共4个，ICW1-ICW4，另一组寄存器是操作命令寄存器组，用来保存操作命令字，OCW共3个，OCW1-OCW3，所以，我们对8259A的编程，也分位初始化和操作两部分

- 一部分是用ICW做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式，其编程就是往8259A的端口发送一系列ICW，由于从一开始就要决定8259A的工作状态，所以要一次性写入很多设置，某些设置之间是具有关联，依赖性的，或许后面的某个位置会依赖前面ICW写入的位置，必须依次写入ICW1,ICW2,ICW3,ICW4
- 另一部分是用OCW来操作控制8259A，前面所说的中断屏蔽和中断结束，就是通过往8259A端口发送OCW实现的



ICW1：

- ICW1用来初始化8259A的连接方式和中断信号的触发方式，连接方式是指用单片工作，还是用多片级联工作，触发方式是指中断请求信号是电平触发，还是边沿触发
- ICW1需要写入到主片的0x20端口和从片的0xA0端口
- 格式如同所示
  - ![image-20230209181117673](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230209181117673.png)

- SNGL：若为1表示单片，若为0，表示级联
- LTIM：用来设置中断检测方式，为0表示边沿触发，为1表示电平触发

ICW2:

- ICW2用于设置起始中断向量号，我们只需要设置IRQ0映射到的中断向量号，其他IRQ接口对应的中断向量号会顺着自动排下来
- 我们只负责填写高5位T3-T7，ID0-ID2这低三位不用咋们负责，我们通过高5位加低3位，便表示了任意一个IRQ接口实际分配的中断向量号
- ![image-20230209185328940](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230209185328940.png)

ICW3

- ICW3用来设置主片和从片用哪个IRQ接口互连
- ICW3又分为主片和从片
  - 对于主片，ICW3置1的那一位对应的IRQ接口用来连接从片，若为0表示接外部设备，若主片IRQ2和IRQ5接从片，则主片的ICW3为00100100
  - 对于从片，ICW3只需要在从片上指定主片用于指定主片用于连接自己的那个IRQ接口就行了，比如主片用IRQ2接口连接从片A，从片A的ICW3的值就应该设为00000010



ICW4

- ICW4用于设置8259A的工作模式，当ICW1中的IC4为1时才需要ICW4
- ![image-20230209191635401](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230209191635401.png)



下面介绍用于操作8259A的各种OCW的格式

OCW1：

- OCW1用于屏蔽连接在8259A上的外部设备的中断信号，实际上就是把OCW1写入IMR寄存器
- OCW1要写入主片的0x21或从片的0xA1端口

OCW2：

- OCW2用来设置中断结束方式和优先级模式
- 要写入到主片的0x20及从片的0xA0端口
- ![image-20230209192447315](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230209192447315.png)
- 如果SL为1，可以用OCW2的低3位来指定位于ISR寄存器中的哪一个中断被终止，也就是结束来自哪个IRQ接口的中断信号，如果SL为0，8259A会自动将正在出来的中断结束，也就是把ISR寄存器中优先级最高的位清0
- 通过R位来设置优先级控制方式，如果R为0，表示固定优先级方式，即IRQ接口号越低，优先级越高
- EOI，EOI为1，则会令ISR寄存器的相应位清0，也就是将当前处理的中断清除，表示处理约束
- 需要注意的是在手动结束中断打断情况下，如果中断来自主片，只需要向主片发送EOI，如果中断来自从片，除了向从片发送EOI以外，还要向主片发送EOI
- ![image-20230209193452448](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230209193452448.png)

OCW3：在本次项目中没有使用

## 中断处理程序代码部分

我们将通过8259A打开中断，实现第一个中断处理程序

intel芯片位于主板上的南桥芯片中，，我们不需要像网卡，硬盘那样单独安装才能用，也不需要为它的各个IR引脚指定连接的外部设备，比如主片IR0引脚上就是时钟中断，这已经由内部电路实现了，我们只需要直接操作8259A就行，不用担心这些外部设备是否连接上了8259A

启动中断流程

- init_all:用来初始化所有的设备及数据结构，首先会调用idt_init
- idt_init分为两部分,pic_init用来初始化可编程中断控制器8259A,ide_desc_init进行初始化中断描述符表IDT
- 加载IDT
  - 我们先用汇编语言实现中断处理程序，之后我们会用C语言写



这里需要补充一下汇编宏的写法：

```c
%macro mul_add 3
mov eax,%1
add eax,%2
add eax,%3
%endmacro
```

用此方法调用：mul_add 45,24,33，其中%1是45，%2是24，%3是33

首先我们需要统一栈中格式，没有错误码的中断就手工加一个0

```c
%define ERROR_CODE nop		 ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.
%define ZERO push 0		 ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0
```

我们先实现一个打印interrupt occur的中断处理函数

首先定义一个存储中断入口程序的地址的变量，数组是高级语言中出现的东西，如果我们想在汇编中实现的话，可以首地址+（索引X元素大小）

```c
%macro VECTOR 2
section .text
intr%1entry:		 ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少
   %2
   push intr_str
   call put_str
   add esp,4			 ; 跳过参数

   ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI 
   mov al,0x20                   ; 中断结束命令EOI
   out 0xa0,al                   ; 向从片发送
   out 0x20,al                   ; 向主片发送

   add esp,4			 ; 跨过error_code
   iret				 ; 从中断返回,32位下等同指令iretd

section .data
   dd    intr%1entry	 ; 存储各个中断入口程序的地址，形成intr_entry_table数组
%endmacro
```

同时我们定义33个中断处理函数

```c
VECTOR 0x00,ZERO
VECTOR 0x01,ZERO
VECTOR 0x02,ZERO
VECTOR 0x03,ZERO 
VECTOR 0x04,ZERO
VECTOR 0x05,ZERO
VECTOR 0x06,ZERO
VECTOR 0x07,ZERO 
VECTOR 0x08,ERROR_CODE
VECTOR 0x09,ZERO
VECTOR 0x0a,ERROR_CODE
VECTOR 0x0b,ERROR_CODE 
VECTOR 0x0c,ZERO
VECTOR 0x0d,ERROR_CODE
VECTOR 0x0e,ERROR_CODE
VECTOR 0x0f,ZERO 
VECTOR 0x10,ZERO
VECTOR 0x11,ERROR_CODE
VECTOR 0x12,ZERO
VECTOR 0x13,ZERO 
VECTOR 0x14,ZERO
VECTOR 0x15,ZERO
VECTOR 0x16,ZERO
VECTOR 0x17,ZERO 
VECTOR 0x18,ERROR_CODE
VECTOR 0x19,ZERO
VECTOR 0x1a,ERROR_CODE
VECTOR 0x1b,ERROR_CODE 
VECTOR 0x1c,ZERO
VECTOR 0x1d,ERROR_CODE
VECTOR 0x1e,ERROR_CODE
VECTOR 0x1f,ZERO 
VECTOR 0x20,ZERO
```

我们在kernel.S中定义了一个数组，数组名为intr_entry_table

```c
global intr_entry_table
intr_entry_table:
```

这里说明一下为什么要定义33个中断处理程序

原因是中断向量0-19为处理器内部固定的异常类型，20-31是intel保留的，所以我们可用的中断向量号最低是32.将来我们在设置8259A的时候，会将IR0的中断向量号设置为32

### 创建中断描述符表IDT，安装中断处理程序

此处将中断描述符表展示出来：

![image-20230209223707255](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230209223707255.png)

中断描述符结构体：

```c
/*中断门描述符结构体*/
struct gate_desc {
   uint16_t    func_offset_low_word;
   uint16_t    selector;
   uint8_t     dcount;   //此项为双字计数字段，是门描述符中的第4字节。此项固定值，不用考虑
   uint8_t     attribute;
   uint16_t    func_offset_high_word;
};
```

我们先通过宏把8259A用到的端口号定义出来：

```c
#define PIC_M_CTRL 0x20	       // 这里用的可编程中断控制器是8259A,主片的控制端口是0x20
#define PIC_M_DATA 0x21	       // 主片的数据端口是0x21
#define PIC_S_CTRL 0xa0	       // 从片的控制端口是0xa0
#define PIC_S_DATA 0xa1	       // 从片的数据端口是0xa1
#define IDT_DESC_CNT 0x21	 // 目前总共支持的中断数
```

IDT描述符属性和选择子

```c
#define SELECTOR_K_CODE	   ((1 << 3) + (TI_GDT << 2) + RPL0)
#define SELECTOR_K_DATA	   ((2 << 3) + (TI_GDT << 2) + RPL0)
#define SELECTOR_K_STACK   SELECTOR_K_DATA 
#define SELECTOR_K_GS	   ((3 << 3) + (TI_GDT << 2) + RPL0)

//--------------   IDT描述符属性  ------------
#define	 IDT_DESC_P	 1 
#define	 IDT_DESC_DPL0   0
#define	 IDT_DESC_DPL3   3
#define	 IDT_DESC_32_TYPE     0xE   // 32位的门
#define	 IDT_DESC_16_TYPE     0x6   // 16位的门，不用，定义它只为和32位门区分
#define	 IDT_DESC_ATTR_DPL0  ((IDT_DESC_P << 7) + (IDT_DESC_DPL0 << 5) + IDT_DESC_32_TYPE)
#define	 IDT_DESC_ATTR_DPL3  ((IDT_DESC_P << 7) + (IDT_DESC_DPL3 << 5) + IDT_DESC_32_TYPE)
```

为了方便将数据写入端口中，我们定义了C语言函数将端口读取封装了起来

```c
/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
/******************************************************/
}

/* 将addr处起始的word_cnt个字写入端口port */
static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {
/*********************************************************
   +表示此限制即做输入又做输出.
   outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, 
   已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
   return data;
}

/* 将从端口port读入的word_cnt个字写入addr */
static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {
/******************************************************
   insw是将从端口port处读入的16位内容写入es:edi指向的内存,
   我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,
   此时不用担心数据错乱。*/
   asm volatile ("cld; rep insw" : "+D" (addr), "+c" (word_cnt) : "d" (port) : "memory");
/******************************************************/
}
```

#### 初始化可编程中断控制器

```c
/* 初始化可编程中断控制器8259A */
static void pic_init(void) {

   /* 初始化主片 */
   outb (PIC_M_CTRL, 0x11);   // ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_M_DATA, 0x20);   // ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
   outb (PIC_M_DATA, 0x04);   // ICW3: IR2接从片. 
   outb (PIC_M_DATA, 0x01);   // ICW4: 8086模式, 正常EOI

   /* 初始化从片 */
   outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
   outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
   outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
   outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI

   /* 打开主片上IR0,也就是目前只接受时钟产生的中断 */
   outb (PIC_M_DATA, 0xfe);
   outb (PIC_S_DATA, 0xff);
}
```

#### 创建中断门描述符

```c
/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
   p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
   p_gdesc->selector = SELECTOR_K_CODE;
   p_gdesc->dcount = 0;
   p_gdesc->attribute = attr;
   p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
}
```

#### 初始化中断描述符表

```c
static struct gate_desc idt[IDT_DESC_CNT];   // idt是中断描述符表,本质上就是个中断门描述符数组
/*初始化中断描述符表*/
static void idt_desc_init(void) {
   int i;
   for (i = 0; i < IDT_DESC_CNT; i++) {
      make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
   }
}
```

#### 完成有关中断的所有初始化工作

```c
/*完成有关中断的所有初始化工作*/
void idt_init() {
   put_str("idt_init start\n");
   idt_desc_init();	   // 初始化中断描述符表
   pic_init();		   // 初始化8259A

   /* 加载idt */
   uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
   asm volatile("lidt %0" : : "m" (idt_operand));

}
```

