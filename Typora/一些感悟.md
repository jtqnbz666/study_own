5.登录的时候有一些数据不是实时的可以考虑丢给脚本处理，业务从缓存读

4.对于一些非结构化的数据，尽量不要用_来拼， 可以用json存字符串

3.对于没有保序的场景，比如选英雄的时候，服务器可以根据一个一直递增的序号来决定需要处理的消息，比如处理了5之后就不处理3了（这样的话，前端根本不用等后端返回

2.选择英雄皮肤的时候不要搞什么只选皮肤的字段，选择过程可能有时序问题，如果有这种字段反而容易出错

1.线程理解：在之前做的项目，线程都是用的线程池， 但游戏中单个房间会有一个游戏线程以及状态机和消息队列， 这个游戏线程只负责处理这个消息队列里面的消息，保证消息的顺序性

2. 感觉c++语法更加严谨， 指针和普通对象分的很清楚， 而像c#没有单独的符号来表示指针变量 
3. 领奖的时候要加redis锁限制
4. 英雄选择完之后一并发送设置相关的消息， 这个时候可以重新倒计时5秒，利用间隙去发
5. 各个服务器的交互需要注意幂等性
6. 接口注意合并， 访问的是同一张数据库的表的感觉都可以合并
7. 初始化的时候可以建立一些映射关系（比如我之前的皮肤和英雄），还有就是一些时间戳（比如配表中一些固定时间戳），如果不存到数据库，那就可以一开始就把时间信息加载好，就不用每次都去加载了
8. mysql的表设计的时候就要考虑下通用字段，能少加就少加，参考石灵之地的任务表
9. 加货币类型要慎重， 可能加道具就能解决(比如活动的各种资源) , 货币和道具分开是因为考虑效率
10. 最好不要类型配合ID作为key， 比如奖励，再比如活动,  都应该使用唯一id来标识(更好理解，开发上也会更容易)
11. 做排行榜的时候，yikai指导单做一个服务器，后来hanyu说lbs和uds有相互调用的逻辑，不应该单独做一个服务，应该都放在uds的
12. 英雄战力分之前是在战斗服算好再给uds的， 但这样不好， 比如跨赛季的时候，uds都已经把英雄分重新计算了， 此时战斗服给的数据就不准确。所以类似这种资源(这里指英雄)相关的业务逻辑计算不应该在多个服务上
13. 最好有一个类似线上的服务器环境，新版本上线的时候方便测试（比如排行榜迁移数据
14. tcp虽然有序， 但应用层处理的时候可能乱序， 比如328的战斗服，处理消息的时候用的是异步方法
15. 选择英雄可以让后端比前端晚0.5s，主要就是避免状态机切换导致前端最后时刻发的消息得不到处理