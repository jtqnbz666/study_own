DHCP:八种报文类型，主要掌握四种，discover， offer，request，ack， 其中discover和request一定是广播， offer和ack可以选择设置，request也是广播是因为要通知其他DHCP服务器自己选择的谁， 不可能每个子网都有DHCP服务器，所以需要一个dhcp中继代理， 子网与dhcp中继代理以广播的方式，中继代理与具体dhcp服务器以单播的方式，dhcp是基于udp的

ICMP(Internet Control Message Protrol：，翻译过来就是互联网控制信息报文协议，因为它提供了多种类型码，对于在网络上传输出现的错误进行了分类，主要是两大类型， 查询报文类型(ping是其中一中)，和 差错报文类型(transroute(linux)是其中一种，但transroute(windows)不是)， 通过返回类型我们就能判断一个包是怎么si的，

对于traceroute(linux)和 trancert(windows)都是刚开始都是把TTL设置成1， 然后通过返回错误，不断增加ttl的值，在这个过程中会记录路由经过的每一个路由的信息(往返时间等)，有一点不同的是tracert是向目标地址发出ICMP请求回显数据包，而traceroute是向目的地址的某个端口(>30000) 发送UDP数据包， 它们的返回结果是不同的，tracert是能够接收到对方的回显的，属于查询类型，而traceroute完全只是为了获取到达目的地的途径，属于差错类型

traceroute有三种类型，基于UDP(Linux下默认使用UDP，如果遇到防火墙屏蔽udp流量时，会改用ICMP作为备选，可以使用 -I（ICMP），- U（UDP）来决定用哪种)，基于ICMP(windows默认，也就是tracert命令) 和 基于TCP的， 基于UDP和基于ICMP的很像，区别在于发出去的接收的包不同，对于UDP向外发送的是一个UDP数据包，收到的是一个ICMP Destination Unreachable(端口不可达，因为30000以上的端口一般都是不存在的)， 对于ICMP向外发送的是一个ICMP Echo Request， 收到的是一个ICMP Echo Reply， transroute的基于ICMP的这种windows默认方法(即tracert)和ping有有点像，发送和接收的都是同一种类型

ICMP是网络层的，但它依赖于IP协议，ICMP是被封装在IP包里面的， 被ping的对象收到这个包之后也会生成一个ICMP包，对应的ICMP类型字段为0(主动请求的应答)， 序列号设置为发送方发过来的序列号，当我们收到结果的时候用现在的时间减去发送时的时间也就得到了RTT(往返时间)，还能够得到TTL的值(比如ping百度的时aram候是56，一开始这个值默认是64,说明跳转了8个路由就找到目的地了)，在规定时间内，若没有收到ICMP的应答，则说明目标主机不可达，同时用当前时刻减去发送时刻就是ICMP数据包的延时

以上的ping为查询报文类型，然后说一下差错报文类型，类型3(终点不可达)、类型4(源抑制)和类型11(超时)
traceroute一开始发送ttl是1的udp数据包，即碰到第一个路由器就si了，然后返回一个ICMP差错报文，类型是11(时间超时)，接下来发送ttl为2的udp数据包

**ping和traceroute的区别**

~~~shell
Ping：Ping命令通常会显示每个发送和接收数据包的统计信息，如往返时间（RTT）和丢包率。    #(发送和接收都是icmp)
Traceroute：Traceroute命令会显示从源主机到目标主机经过的每个中间节点（路由器），以及它们的IP地址和延迟。 # 更细，(linux默认发送是udp，接收都是icmp)
~~~

NAT地址转换：简单说就是公司教室内的主机对外通信，把私有IP转换成共有IP地址， 比如现在公司有两台机器，192.168.1.10 和 192.168.1.11 那么通过NAT路由器是无法做到的， 所以我们需要把IP+port一起进行NAT，比如192.168.1.10:1025 和 192.168.1.11:1025通过NAT路由器分别转化为49.234.61.220:1001 和 49.234.61.220:1002 ，这种转换关系表在NAT路由器上自动生产，但如果NAT路由器崩了，那么所有TCP连接都会重置，所以有两种解决方案， 第一种换成IPv6， 第二种使用NAT穿透技术， 即我们的主机自动获得NAT设置的公有IP，然后自己建立端口映射条目，然后通过这个条目对外通信，这样就不需要NAT设置来进行转换了 

TTL的主要作用是避免IP包在网络中的无限循环和发收，节省网络资源，并且能使发送者收到相关告警信息。

在ip层会分片，为什么还需要在tcp层先分一次？

```
mss是对于tcp层的，mtu是对于ip层的， 如果tcp不分片，假设发送一个很大的数据， 那么如果ip层分片的过程中丢包了，这整个大数据都要重发， 而如果tcp层就分片了，只需要重发丢失的那部分
```



OSI七层模型、四层模型，其实他们的区分标准在于OSI七层模型是理论上的分层方式，而四层模型是实践过程中的分层模型。

![img](https://img-blog.csdnimg.cn/d4b0cd4bcae3420ab07a4240677275b6.png#pic_center)

## 哪个函数控制了三次握手的连接

没有哪个具体的函数控制了连接这种说法，客户端使用connect函数(udp中的connect不进行握手过程)将ip和port拷贝到tcp协议栈中，**具体的三次握手连接是在协议栈中进行的**，当第一次握手成功时，服务端会生成一个相应结点，这个结点保存在**半连接队列**中，它能够表示一个tcp连接的11个状态，**sendbuf，recvbuf也是这个结点的一部分**，每个数据包都包含了五元组的信息，故第三次握手时可以通过五元组信息在半连接队列中找到对应结点放入全连接队列中（注意这里的转移过程不是拷贝）调用accept函数会为之分配一个fd，可以用这个fd来表示它。 这个结点的生命周期一直到通信结束释放。

这里可能大家就有疑问了，那listen()函数用来干什么，listen是用来监听服务端套接字的 (只有监听着这个套接字才能收到客户端发送的连接请求) 保证客户端可以正常与服务端建立三次握手，同时使用了listen函数后也能够在协议栈中判断连接数量来决定是否接受新的连接请求。

半连接队列中结点的生命周期：当第二次握手得不到响应，一直重传第二次握手，到达一定次数后就会释放这些结点资源



## 为什么要三次握手：

第一次握手：Client什么都不能确认，Server确认了对方发送正常，自己接收正常

第二次握手：Client确认了：自己发送、接收正常，对方发送正常、接收正常；Server确认了：对方发送正常，自己接收正常

第三次握手：Client确认了：自己发送、接收正常，对方发送正常接收正常；Server 确认了：对方发送正常，接收正常，自己发送正常，接收正常。

为什么两次握手不行，假设Client给Server发送一个连接请求过去(第一次握手)，但由于网络原因，迟迟没有到达Server端，所以Client端迟迟收不到对方的ACK回应(第二次握手)，这时假设Client不想建立本次连接了，但这个由于网络延迟等原因发送的请求建立包(第一次握手)又到达了Server端，对于Client端来说这是一个没用了的请求连接，但Server端会单方面建立这次连接。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e994ed83de1a470d88ac3c4364d50a9a.png#pic_center)

有发送消息的步骤的函数：connect , send, close, shutdown   
recv看似收到消息后会回复ack确认，但实际这种现象是协议中对收到数据的自我回应，不算在上边。

1：大量time_wait 原因：由图可看出，只有主动发起close的一端才会有time_wait阶段，服务器如果出现大量time_wait，说明是程序中的哪个位置设置不当，服务器主动close了，这时候应该检查服务器程序逻辑代码

2：大量close_wait原因：当recv() == 0，说明对方发起了close断开连接，按照正常情况我们应该直接close来关闭连接，但如果当recv() == 0 出现时，我们在这种情况下还有很多业务代码要处理，这些业务代码就会耽搁close的时间，导致迟迟不能close。

~~~c
if(recv == 0) {
    //假设很多业务逻辑代码
    close(fd);
}
~~~

正确做法，要不直接close(fd),要么另外开一个线程，去执行这些业务逻辑代码，异步实现。

3：大量fin_wait2  

当遇到这种情况，与迟迟收不到对方的close有关，fin_wait1和fin_wait2一样，没有其他方式彻底关闭本次连接(因为在它们主动调用了close之后就一直在等待对方的回应)，这个时候只有唯一的办法就是使用kill 来关闭连接。

4:epollrdhup和epollhup

当对方关闭写端时，我方触发EPOLLRDHUP事件。

当对方读写端都关闭，我方触发EPOLLHUP事件，但实际上我们只需要知道对方的读端关闭，就会触发EPOLLHUP，(因为一个连接的正常关闭都是先对方关闭写端，我方收到消息后关闭读端，想一想FIN断开连接的过程。)这也是为什么有EPOLLHUP,EPOLLRDHUP,但没有EPOLLWRHUP的原因，因为没必要

延申：SIGPIPE当往一个读端关闭的管道或socket写入数据，触发SIGPIPE信号，errno被设置为EPIPE。跟EPOLLHUP类似的效果。

5：列举read(recv) 和 write(send) 不同的情况

![](C:\Users\ASUS\Pictures\博客图片\QQ图片20220801225229.png)

6：四次挥手后等待2MSL作用：

![](C:\Users\ASUS\Pictures\博客图片\20180208112533496.jpg)



MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃

第一点：确保四次挥手的完成，我们要知道TCP有超时重传机制，在发送一个数据包后(这里假设是第三次挥手的数据包)，若在规定的时间内未收到确认包，则会认为数据包丢失，重新发送一次数据包；
在此情况下（客服端向服务端主动发起关闭），假设服务端设置了RTO(Retransmission Time Out,超时重传时间)是2MSL(这个2MSL和四次挥手后的2MSL不是同一个，只是刚好时间长度一样)。服务端发送的FIN+ACK包(第三次挥手)在MSL的**最后一个时刻**传输到了客户端，而客户端回发了ACK包，此时客户端开始了TIME-WAIT(这里说的就是四次挥手后的2MSL等待)；如果这个ACK包经过MSL还未发送到，此时服务端已经超过2MSL为收到ACK包的回应了，服务端就超时重传FIN+ACK包（第三次挥手），**注意注意：这种极端情况下，当服务端超时重传(第二次发送第三次挥手)，对于客户端四次挥手后等待的2MSL来说，它从开始等待到现在这个时刻，已经过去了1MSL,**第二次发送的第三次挥手的生存时间最大是1MSL，所以如果不出意外，客户端四次挥手后等待的2MSL(目前还需等待1MSL)内一定可以收到对方的重传(第二次发送第三次挥手)。

如果第二次发送第三次挥手由于网络等原因还是失败了，对于客户端来讲，四次挥手后等待的2MSL并没有收到任何重传，所以客户端进入close状态，但是服务端也不会傻傻的一直等着，有一个保护机制， FIN 报文的重传次数是受限的，具体由 tcp_orphan_retrie这个参数决定。服务端会重试一段时间，重试次数达到限制，服务端就主动断开了。【达到重试次数时，相当于服务端那边认为已经是出了什么问题，不可能收到这个ACK包，主动断开了】

第二点：防止新的tcp连接收到上一次由于网络等原因迟到的数据包，如果没有这个2msl等待时间(在2msl等待期间，这个端口在默认情况下不能被再使用，不过可以在setsockopt函数中设置SO_REUSEADDR选项，从而不必等待2MSL时间结束再使用此端口。)，假如下一次建立的新连接刚好使用了与上一次一样的端口号，若上一次连接中，对方有由于网络等原因迟到的数据包，有可能将会被这次新的连接接收到而引起错误，每个数据包都是有最大生存时间的，等待2msl确保新的连接不会收到上一次的由于网络等原因迟到的数据包。



双方同时调用connect，可行， 适用场景，tcp的p2p。

tcp，udp是可以绑定相同的端口的，因为五元组中协议不一样



## UDP中connect作用

与tcp相比，tcp会产生三次握手过程， udp不会， tcp只能进行一次connect，udp可以多次调用，1：指定一个新的ip&port连结.2：断开和之前的ip&port的连结.指定新连结,直接设置connect第二个参数即可.断开连结,需要将connect第二个参数中的sin_family设置成 AF_UNSPEC即可.

采用connect的udp发送报文就可以使用send ，write， 仍然可以sendto，但第5个参数必须为NULL，第六个参数是0， 调用recvfrom，recv，read，只能获取到先前connect的ip&port发送的报文。

比如A 与 B ，C 交替通信， 如果并发过大， 有可能出现本来在等B，却收到了C， 所以可以用connect来做并发， 在服务端创建两个udp，需配合bind一起使用。

## 分片问题

对于 UDP 来说. **它并没有协商的能力，所以它只能直接把用户发送的数据，传给网络层（IP层），由网络层来进行分片**。.
对 网络层（IP层）来说：它并不知道上层传过来的数据，到底是 TCP 还是 UDP，它并不关心这个东西，也没有能力去区分。. 
如果发现数据过大，那么 IP 层会自动对数据进行切割，分片。. 注意：**因为 TCP 是在自己这一层执行分片，所以：IP层并不需要再去分片**。 
每个TCP分片，都是包含了完整的 TCP 协议头，这样另一方收到包之后，可以方便重组，可以计算出到底哪个分片包丢了，然后重新传这个分片包。.

## 地址重用，端口重用

服务器和客户端都可以bind，bind并不是服务器的专利，若在客户端使用bind，则表示固定了客户端的port号，本来你不bind，系统会自动为你分配一个未使用的port号，反而你这样操作会自己增加障碍，即同一台电脑不能打开两个客户端(若bind了，端口冲突)

可以把udp并发中的udp_accept理解为bind + connect

SO_REUSEPORT： i
 运行任意数量的socket绑定到相同的（ip，port）二元组
 前提是：每个socket都必须先设置SO_RESUSEPORT。
 而SO_REUSEADDR只需要后面一个socket设置SO_REUSEADDR就能绑定成功。

可以理解为SO_REUSEADDR主要用来解决timewait导致的绑定问题。SO_REUSEPORT也能解决timewait问题。

## 长连接 、短连接

一：如何保持长连接:
1.tcp内部设置keepalived, 2.应用层实现

应用层实现好一点: 可以根据返回结果进一步处理

粘包问题：

讲http， redis 都是基于tcp的，它们怎么处理的

~~~c
1.应用层包头加一个长度， 2.加上特殊分隔符比如http协议，redis协议。3.关闭nagle算法(任意时刻,最多只允许有一个未收到ack的包)， 4.开启tcp PUSH标志 ， 5.每次客户端发送固定大小，服务器接收固定大小

拓展,不仅有nagle算法,还有一个ACK延迟机制,这个延迟机制刚好相反,当server端收到数据后并不会马上回复客户端ACK, 而是会延迟一段时间,它认为这段时间内,服务器会发送数据,顺带着把这个ACK带过去
~~~

二：websocket使用场景：
1.比如扫描二维码登录过程(网页给出二维码，微信扫描将数据上传到微信服务器，微信服务器将数据发送给该网页的服务器，网页的服务器验证后通知网页结果)
2.页游(服务器给网页推送消息)



**server直接保存fd不就是长连接？**

~~~c
这样确实是长连接，但可能是僵尸连接，早就断开了，但不知道，websocket相当于是实现了满足需求的长连接 
1.需要设置心跳包来验活
2.握手过程， 简单验证
像IM即时通信的自定义协议也相当于实现了长连接
~~~

握手过程：![1670503606350](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1670503606350.png)





## http1.0 ,http1.1 , http2.0

非持久连接：HTTP/1.0 中 的首部字段Connection 默认值为 close，即每次请求都会重新建立和断开 TCP 连接.
持久连接：HTTP/1.1 中 的首部字段Connection 默认值为 keep-alive ，连接可以复用，只要发送端、接收端都没有提出断开连接，则保持tcp连接状态。
http1.1中，所有的连接默认为持久连接，但在http1.0中并未标准化，即使有部分的服务器通过非标准化的手段实现了持久连接，但是服务器端不一定支持持久连接
持久连接的优点：
减少了tcp连接的重复建立和断开所造成的额外开销，减轻了服务器端的负担，其中减少开销的这部分时间实际上也使http请求和响应更早的结束，提高了web页面的显示速度

不管是否是长连接,  这只是跟网络消耗有关, 真正的对于状态的保持还是要cookie和session机制配合

对于http的1.0 和 1.1, 默认都是发送一次请求,接收到回复之后再发送另外一条请求, 但http1.1有一个pipe line的管道技术, 支持同时发送多个请求, 但是默认是关闭了这项技术的,因为按道理来说发送的请求也应该按顺序返回结果, 那么如果第一个请求阻塞了, 后边的请求都无法返回，也就是我们所说的队头阻塞的问题， 如果是http长连接，还有一个keepalive_timeout参数， 如果长时间(1min)没有发送请求，那么就关闭本次连接，释放资源

http1.1如果想默认是支持长连接的, 因为它的Connection: Keep-Alive 配置, 而http1.0 默认是Connection: close
需要注意的是http中的Keep-Alive和tcp中的Keepalive不是同一个东西, tcp中的那个是tcp的保活机制(也叫心跳检测), 如果对方宕机或者出现一些什么意外情况导致报文不可达, 根据一定的心跳策略连续发送几次心跳包还没有收到回应,那么说明该tcp连接已经无用,这个工作是在tcp内核中完成的, 同时需要注意的是尽管tcp心跳机制正常,只能说明tcp是正常的,但不能保证应用程序能正常进行工作,所以一般我们还需要在应用层面设计心跳包机制.

http2.0 采用了头部压缩(因为有多个报文，很多头部字段都相似), 二进制的方式, 多路复用,但它的多路复用有个弊端就是同样存在队头阻塞的问题,因为复用的http请求都在同一个tcp滑动窗口上



grpc 用了protobuf(把IM协议中的message 换成 service)， 功能实现简单，不用自定义协议，不用封装，它都做好了

![1670589280064](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1670589280064.png)

304http缓存设计， 如果客户端缓存时间到期了，去服务器对比后发现，服务器还是原来客户端缓存的数据，这时候服务器就回应304，不带数据，告诉客户端继续使用以前缓存的那份数据
200， 201(表示服务器已经成功处理，并且创建了新的资源，一般出现在post请求的返回上)， 301(永久重定向)， 302(临时重定向)， 401(未认证用户信息)， 403(权限不够) ，500(服务器内部错误无法处理请求，比如连接不上数据库)，502(上游服务返回不正确的值， 比如nginx作为反向代理时，接受到业务服务器的不正确返回时)，503(负载大，维护)， 504(和502类似， 但是返回是正确的，只是超过了指定的时间), 505(不支持的http协议，比如过时的版本)