小知识

~~~shell
10.字节序列中如果能用ascii码直接显示的就会直接显示比如\\和\n
9.unicode的字符集前255和labtin1一样，前127和ascii一样
8. print("\u4f60\u597d") # 你好， python自动换成了unicode对应的字符
7.unicode中\u 前缀用于表示四位的十六进制Unicode码点，而\x前缀用于表示单字节的十六进制值。
6.八进制转义字符：在第一次 json.dumps 时被转换为 Unicode 转义字符，因为 JSON 规范要求非 ASCII 字符以 Unicode 转义形式表示。
5.将字符串转换为字节序列，bytes(str, "utf-8")或者str.encode('utf-8')，str可以是空字符串，这里只是用utf-8演示，根据实际需求选用，比如latin1, unicode-escape
4.b'\x01'、b'\001'是单字节字节序,b'\u0001'不是单字节序，unicode码点格式为\u后边跟4个16进制数，并不是单字节的字节序，所以b'\u0001'完全就认为它是6个单字节字符的组合，打印结果是b'\\u0001'，这也就可以理解为什么unicode-escape编码的打印结果是字符串形式了，对于8进制而言b'\377'刚好是10进制255，超过这个值编译器会从0开始，比如b'\401'(b'\1')会认为它是b'\x01'。
3.不管8进制转义字符如'\001'还是16进制转义字符'\x01'或者unicode转义字符'\u0001', 他们都只是数字1的不同表达形式，并不是字节序。直接print它们得到的结果都是一样的
2.unicode-escape 主要用于在字符串中表示非ASCII字符，utf-8用于存储和传输unicode字符。
1.python中打印proto对象时，如果内容包含utf8的16进制会以8进制的形式展示，比如有某个字段是bytes类型，里面的内容是'\e5'会展示成'\345'(本质上等价，只是不同显示方式)
~~~

case

~~~shell
1.八进制字符串转中文（proto中有字段类型为bytes时，打印整个proto可以看到该字段的中文为八进制
octal_str = "\345\256\242\346\234\215\346\250\241\346\235\277\346\265\213\350\257\2253"
print(octal_str.encode('latin1').decode('utf-8'))
2.unicode转中文（json.dumps时非ASCII字符会被转为unicode编码
octal_str = "\u00e5\u00ae\u00a2\u00e6\u009c\u008d\u00e6\u00a8\u00a1\u00e6\u009d\u00bf\u00e6\u00b5\u008b\u00e8\u00af\u0095"
# 使用 'unicode-escape' 解码转义序列为字节串
decoded_bytes = octal_str.encode('latin1').decode('utf-8')
3.str = '客服'
print(str.encode('utf-8')) # b'\xe5\xae\xa2\xe6\x9c\x8d'
可以看到‘客’字被编码为了三个字节，它的八进制形态是 b'\345\256\242\346\234\215',
假设str = '\xe5\xae\xa2\xe6\x9c\x8d'或者八进制形态，注意区别是没有b''即不是二进制，要转为中文不能用utf-8编码必须用latin1，因为latin1的编码范围是255，它认识\xe5并且会编码为b'\xe5',而utf-8会把\e5编码为b'xc3\xa5'，因为它大于了127会用两个字节进行编码，如果str内容都是127以下的，那么用latin1和utf-8都可以。
4.比如‘客’字的unicode码是u5ba2, 用utf-8编码后就是b'\xe5\xae\xa2'，直接打印'\xe5\xae\xa2'等价于打印'\u00e5\u00ae\u00a2'，它会逐个字符的找到对应的unicode字符，打印结果为å®¢，如果直接打印'u5ba2',找到的unicode字符就是‘客’字。
~~~

转义字符

~~~shell
八进制转义字符:'\123'，\跟一个3位的八进制数
unicode转义字符:'\u4f60'，\u跟一个4位的十六进制数，里面的u4f60称为unicode码点
特殊转义字符:'\n', \后跟一个特定字符，如果不符合转义字符规范，比如'\o'会被认为是两个字符(反斜杠和字母o)，等价于'\\o'。
常见特殊转义字符：
\\：反斜杠（特别关注，经常打印中看到，其实就是反斜杠这个字符）
\'：单引号
\"：双引号	（以上三个都是能实际看到符号的，比如反斜杠，单、双引号）
\n：换行符
\r：回车符
\t：制表符
\0：空字符
\a：响铃
# 转义字符和普通字符是不一样的，比如'\u4f60'是转义字符，'\\u4f60'是\u4f60字符串
# 只要是转义字符，不管是哪种形式，utf-8或latin1编码时都能识别出来
# 8进制和16进制可以用于表示字节序，但unicode转义字符不行，比如b'\001'和b'\x01'是字节序，而b'\u0001'却不是字节序（而是包含六个字符的字符串）
~~~

unicode_escape编码

~~~python
unicode-escape 编码方式主要用于调试和显示目的，方便查看字符串中的 Unicode 字符。它不是一种用于数据传输或存储的标准编码方式。 

# 编码过程
str = '你'
str = str.encode('unicode-escape') # b'\\u4f60' 并不是b'\u4f60'

# 解码过程
str = '\\u4f60'  # 而不是'\u4f60'，因为unicode-escape处理的是字符串
str = str.encode('utf-8').decode('unicode-escape') # utf-8和latin1都行，因为并不是'\u4f60',如果是话就不能用latin1编码，并且该语句也无法正确解析了，因为unicode-escape只能正确处理'\\u4f60'
print(str) # 你

# 加一层转义 （与json.dumps一起理解）
str = '\u4f60' # 等价于str = '你'
print(str.encode('unicode-escape')) # b'\\u4f60'

# 去掉一层转义 （与json.loads一起理解）
str = '\\nHello\\nWorld\\n'
str.encode('utf-8').decode('unicode-escape') # '\nHello\nWorld\n'

# 为什么打印出来是b'\\u4f60'而不是b'u4f60',因为这个方法会生成unicode的转义序列(也就是带有斜杠的转义字符如\u4f60），是一个由六个字符组成的字符串，打印出来就是b'\\u4f60'
~~~

utf-8编码

~~~shell
# 单字节情况
'\123'的unicode码点是'\u0053'，范围在U+0000到 U+007F,所以'\123'.encode('utf-8')得到的结果跟ascii码一样，程序会以16进制形式展示也就是'\x53'。
'\u0053'.encode('utf-8')也是'\x53'
# 多字节情况
1. '\345'的unicode码点是'\u00e5'，范围在U+0080 到 U+07FF需要双字节表示，所以'\345'.encode('utf-8')得到的结果是 b'xc3\xa5', '\u00e5'.encode('utf-8')结果一样
2. '\u4f60'的unicode码点是'\u4f60'，范围在 U+0800 到 U+FFFF需要三字节表示，所以
'\u4f60'.encode('utf-8') 结果为 b'\xe4\xbd\xa0'
~~~

latin1编码

~~~shell
1.单字节编码：每个字符占用一个字节（8 位），总共可以表示 256 个字符
2.字符集：包含了从 0 到 255 的字符，其中前 128 个字符与 ASCII 相同，后 128 个字符包括了许多西欧语言的特殊字符。
'\345'和'\u00e5'在255范围内，会被编码为单字节b'\xe5'
'\345'.encode('latin1').decode('latin1') # 结果为å
'\u4f60'这是'你'的unicode转义字符，超过了范围，无法用latin1编码，会报错
~~~

#### **ascii、latin1、unicode****、utf-8对比

```
1.ascii和latin1既是字符集又是编码方式
2.unicode只是字符集而utf-8是常用于对unicode字符进行编码的方式
3.unicode字符集前256个字符和labtin1一样，前128个字符和ascii一样
4.比如对'\xe5'编码，期望的结果是b'\xe5'就必须用latin1，因为它超过了127的范围，所以不能用ascii编码，同样如果是utf-8编码会变成两个字节b'\xc3\xa5',只有latin1能成功编码为b'\xe5',如果是一个小于128的字节那么三种编码方式都可以。
```
