1109(n个航班，差分，前缀和)、307(区域与检索，数组可修改)、10.10(面试题)

下标从1开始， 把Sum0 赋值为0， 

lowbit(i): 代表i这个数字的二进制中的最后一位1的位权

lowbit(8) = (1000) = 8
lowbit(6) = (110) = 2
lowbit(12) = (1100) = 4

lowbit(i) = (x & -x)



![](..\..\pic\20230325140800.png)

单点修改问题：

比如第四项发生改变，那么在4头上的位置都要修改，并且上一层的位置为 i + lowbig(i) 项，不能超过 i 的范围

~~~c++
void add(int i, int x) {
    while(i <= n) c[i] += x, i += lowbit(i);
}
~~~



树状数组的前缀和公式

C[ i ] 代表的是从第i项开始向前数logbit(i)项的和， 比如C[ 7 ]就是第七项开始向前数lowbit(7)（也就是1 ）项的和， 就是它本身

S[ i ] = S[ i - lowbit(i) ] + C[ i ]

S[7] = S[6] + C[7] = S[4] + C[6] + C[7] = C[4] + C[6] + C[7]

~~~c++
int quert(x) { //求前x位的前缀和
    int sum = 0;
    while(x) sum += c[x], x -= lowbit(x);
    return sum;
}
~~~



记住一个重要概念：原数组相当于它的差分数组的前缀和数组 ，对原数组的一个区间进行修改，可以转化为对元素组的差分数组的两个单点进行修改。



