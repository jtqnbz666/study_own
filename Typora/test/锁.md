三.条件变量和信号量的区别：

（1）最大的区别应该是使用条件变量可以一次唤醒所有等待者，但信号量不行。

（2）信号量有一个表示状态的值，而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。从实现上来说一个信号量可以是用mutex + counter + condition variable实现的。因为信号量有一个状态，如果想精准的同步，那么信号量可能会有特殊的地方。信号量可以解决条件变量中存在的唤醒丢失问题。

（3）在Posix.1基本原理一文声称，有了互斥锁和条件变量还提供信号量的原因是：“本标准提供信号量的主要目的是提供一种进程间同步的方式，这些进程可能共享也可能不共享内存区。互斥锁和条件变量是作为线程间的同步机制说明的，这些线程总是共享(某个)内存区。”尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。信号量最有用的场景是用以指明可用资源的数量。



问：如何实现++i和i++的原子性

1.单CPU，使用锁或者禁止多线程调度，单核CPU的并发是伪并发，在单核CPU中，如果不存在阻塞的设计部分就没必要使用多线程。

我们好好分析一下为什么需要锁或者多线程调度：
当只有一个线程的时候，一定就会顺利执行i++，因为不存在线程的切换。
当单核环境下使用多线程，并且不加锁，同样可能出现下面情况

![1663216058754](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1663216058754.png)

2.多核CPU，需要借助一些硬件特性来锁住总线， 防止在一个i++操作(包括：读取，修改，写入三个过程)过程中，其他CPU来造成干扰，具体是如何做到的防止的呢，其实加锁过程我们所面临的问题本质就是对一个内存中的变量(一般指的是lock锁变量)进行加锁的过程中，可能会有多个cpu同时对这个变量进行操作而导致最终的结果不准确，但我们可以使用TLS或者XCHG(这两个都是汇编指令)，来实现保证只有一个cpu对这个内存中的变量(一般指的是lock锁变量)操作成功。因为使用TLS或者XCHG的时候，它们都只是一条汇编指令，我们需要清楚一点的是，在单CPU环境中，就算发生中断(导致线程切换去处理中断)，也是在一条汇编指令结束后才会去处理这个中断，即中断是发生在指令之间的，而不会影响单个指令的原子执行，并且TLS和XCHG会锁住总线,其他CPU就暂时不能使用总线了，这样一来我们可以认为现在就是一个单核的环境，并且我们通过TLS或XCHG一条指令原子性的设置成功了这个lock锁变量。这样一来我们就成功实现加锁(实际上就是将这个lock锁变量设置为1)，其他CPU(线程)再次访问到这个锁变量时，发现是1，则等待或者切换其他线程。



上边说的总线的意思：在X86体系中，CPU提供了HLOCK pin引线，允许CPU在执行某一个指令(仅仅是一个指令，比如TLS,XCHG)时拉低HLOCK pin引线的点位，直到这个指令执行完毕才放开，从而锁住总线，这样一来，在同一总线的CPU就在暂时无法通过总线访问内存了，这样就能保证多核处理器的原子性(但也正因为锁了总线，别的CPU无法使用总线对性能会造成一定的影响。





自旋锁有三种实现

1:单CPU。不可抢占内核中， 自旋锁为空操作；

2：单cpu， 可抢占式内核中， 自旋锁实现为"禁止内核抢占"，并不实现自旋

3：在多CPU 中， 可抢占内核， 自旋锁实现为“禁止内核抢占”+ 自旋

被自旋锁保护的临界区代码执行时，它不能因为任何原因放弃处理器

所以现代处理器在处理自旋锁时都会**设定自旋上限事件以防死锁**

