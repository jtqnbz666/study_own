 # 		文件：

## 1.文件相关知识

1.mmap作用：常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程

文件内容操作：
		创建，打开文件
		读写文件
		文件内容指针操作
		关闭保存文件

​	C:  FILE* fopen  fread  fwrite  fscanf  fprintf  fseek  fclose
​	C++:fstream   .open   .read  .write  ...
​	windows:HFILE  CreateFile  ReadFile   WriteFile

Linux:  

​	int fd;//文件描述符

​	int open( 			//失败返回-1  成功返回fd
​			const  char * filename,  //文件名
​			int flags,			//创建或者打开方式
​			mode_t mode);			//文件权限

文件操作：
		拷贝文件，删除文件，移动文件，获取文件信息

文件映射
		文件--->硬盘

​		硬盘  容量大  访问速度慢  价格便宜   掉电不流失
​		内存  容量小   访问速度快   价格贵   掉电流失

## 2.文件拷贝

具体实现指令是

先gcc  文件  生成a.out可执行文件

再./a.out  依赖文件  目标文件

```c++
//copyfile.c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
int main(int argc,char *argv[])
{
#if 1	//通过指令的方式实现
	char buff[256]={0};
	sprintf(buff,"cp %s %s",argv[1],argv[2]);

	system(buff);
#else	//自己的代码实现
	int fdSrc,fdDst;
	fdSrc=open(argv[1],O_RDONLY);
	fdDst=open(argv[2],O_WRONLY|O_CREAT,0666);
	int r;
	char buff[1024];
	while(1)
	{
		r=read(fdSrc,buff,1024);
		if(r>0)
		{
			write(fdDst,buff,r);
		}
		else
			break;
	}
	close(fdSrc);
	close(fdDst);
#endif
	return 0;
}
```





## 3.获取文件状态

具体实现指令是

gcc  文件生成可执行文件 a.out
再 ./a.out 目标文件

~~~c++
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>// close
#include <sys/stat.h>
#include <stdlib.h>//exit
int main(int argc,char*argv[])

{

	struct stat st={0};
	int ret=stat(argv[1],&st);
	if(ret)
	{
		printf("获取%s状态失败！\n",argv[1]);
	}
	else
		{
			printf("获取%s状态成功！\n",argv[1]);
		if(st.st_mode&S_IFDIR)
		{
			printf("是个目录文件！\n");

		}
		else
		{
			printf("是个普通文件！\n");
		}
		//printf("%s\n",st.st_atim);
		}
	
	return 0;
}
~~~

## 4.普通文件读写方式

### 4.1 对文件进行写操作

~~~c++
//open.c写操作
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>//close需要
#include <stdlib.h>//exit是一个系统函数
struct student 
{
int num;
char name[20];
int age;
double score;
};
int main()
{
	int fd=open("2.txt",O_WRONLY);
	if(-1==fd)
	{
		//print("打开文件失败：%m\n");  //%m的作用是直接将错误信息显示出来
		//perror("打开文件失败！：\n");
		//return -1;
		fd=open("2.txt",O_CREAT|O_WRONLY,0666);
		if(-1==fd)
		{
			printf("创建文件失败！\n");
		}
		printf("创建文件成功！\n");
		close(fd);
		fd=open("2.txt",O_WRONLY);

	}
	printf("打开文件成功!\n");
	struct student stu[5]=
	{
		{1,"江涛",20,66.66},
		{2,"王慧",30,88.88},
		{3,"利息",40,55.55},
		{4,"李培明",60,44.44},
		{5,"往加量",50,33.33},
	};
	for(int i=0;i<5;i++)
	{
		write(fd,&stu[i],sizeof(struct student));
	}
	//write(fd,stu,sizeof(struct student)*5);
	close(fd);
	return 0;
}
~~~

### 4.2对文件进行读操作

~~~c++
//read.c读操作
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
struct student
{
	int id;
	char name[20];
	int age;
	double score;
};
int main()
{

	int fd=open("2.txt",O_RDONLY);
	if(-1==fd)
	{
		printf("打开文件失败！:%m\n");
		exit(-1);
	}
	printf("打开文件成功！\n");
	struct student s;
	for(int i=0;i<5;i++)
	{
		read(fd,&s,sizeof(struct student));
		printf("id:%d,name:%s,age:%d,score:%g\n",s.id,s.name,s.age,s.score);
	}
	close(fd);
	return  0;
}
~~~

### 4.3通过lseek读取文件内容

具体使用指令：
gcc 文件先生成可执行文件a.out
再 ./a.out 目标文件

~~~c++
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>//close
#include <stdlib.h>//exit
int main()
{
	int fd=open("test.txt",O_RDONLY);
	if(fd==-1)
	{
		printf("打开文件失败！：%m\n");
		exit(-1);
	}
	printf("文件打开成功！\n");
	char c;
	int r;
	while(1)
	{
		r=read(fd,&c,1);
		if(r>0)
		{
			printf("%c\n",c);

		}
		else
			break;
		lseek(fd,3,SEEK_CUR);
	}
	close(fd);
	return 0;
}
~~~



## 5.文件映射虚拟内存读写方式

常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程

IO操作  读写文件 内存-->硬盘(写)     硬盘-->内存(读)

把文件映射到内存中：操作内存段就是操作文件

文件映射虚拟内存编程模型步骤。

- 1.打开文件  					open
- 2.修改文件大小           ftruncate
- 3.挂载映射                    mmap
- 4.使用虚拟内存(文件)      指针方式
- 5.卸载映射                  munmap
- 6.关闭文件                   close

### 5.1.写内容到文件

~~~c++
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
struct student
{
	int id;
	char name[20];
	int age;
	double score;
};
int main()
//	1 创建文件
{
	int fd=open("stu.dat",O_CREAT|O_RDWR);
	if(-1==fd)printf("打开文件失败：%m\n"),exit(-1);
	printf("打开文件成功！\n");

	//2.修改文件大小
	ftruncate(fd,3*sizeof(struct student));
	//3.映射虚拟内存
	struct student*pp=mmap(NULL,3*sizeof(struct student),
		PROT_WRITE|PROT_READ,MAP_SHARED,fd,0);
	if((void*)-1==pp)
		printf("映射虚拟内存失败：%m"),close(fd),exit(-1);
	printf("映射虚拟内存成功!\n");


	//4.使用内存
	struct student*ppp=pp;
	ppp->id=1;
	strcpy(ppp->name,"张三");
	ppp->age=33;
	ppp->score=1.3;
	printf("写入一个人的数据！\n");
	ppp++;
	ppp->id=2;
	strcpy(ppp->name,"李四");
	ppp->age=44;
	ppp->score=4.3;
	ppp++;
	ppp->id=3;
	strcpy(ppp->name,"王五");
	ppp->age=55;
	ppp->score=51.3;

	printf("写入数据完毕！\n");
	//5 .接触虚拟内存映射
	int ret=munmap(pp,3*sizeof(struct student));
	if(ret)
		printf("munmap失败：%m"),exit(-1);
	printf("munmap成功！\n");	
	
	//7.关闭文件
	close(fd);
	return 0;

}
~~~



### 5.2.读取文件内容

~~~c++
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <stdlib.h>
struct student
{
	int id;
	char name[20];
	int age;
	double score;
};
int main()
{

	int fd=open("stu.dat",O_RDONLY);
	struct student*p=mmap(NULL,3*sizeof(struct student),
		PROT_READ,MAP_SHARED,fd,0);
	struct student*pp=p;
	for(int i=0;i<3;i++)
	{
		printf("%d:%s:%d:%g\n",pp->id,pp->name,pp->age,pp->score);
		pp++;
	}
	munmap(p,3*sizeof(struct student));
	close(fd);
	return 0;
}
~~~

## 5.多文件编译

首先掌握编译链接过程的知识

细节：除了main.c只有源文件，其余都需要一个.c一个.h文件

我们以对两个数据进行加减运算举例，通过两个文件夹来分别实现加和减操作。

 '加'文件 add.c

~~~c++

int add(int a,int b)
{
	return a+b;
}
~~~

 '加'文件 add.h

~~~c++
#ifndef  _ADD_H
#define _ADD_H
int add(int ,int );
#endif
~~~

'减'文件 sub.c

~~~C++

#include <stdio.h>
int sub(int a,int b)
{
	return a-b;
}
~~~

'减'文件 sub.h

~~~c++
#ifndef  _SUB_H
#define		_SUB_H
int sub(int ,int);

#endif
~~~

源文件main.c

~~~c++
#include <stdio.h>
#include "add.h"
#include "sub.h"
int main()
{
	int a,b;
	printf("请输入两个数来进行运算！\n");
	scanf("%d%d",&a,&b);
	printf("%d+%d=%d\n%d-%d=%d",a,b,add(a,b),a,b,sub(a,b));
	return 0;
}
~~~

具体实现流程
先 gcc -c所有的.c 文件 生成 .o文件
再 gcc *.o  -o  math.exe(这里的math.exe随便你写什么，其实就是一个可执行文件，若不用-o 默认生成a.out)

~~~makefile
#第一步
gcc -c main.c -o main.o
gcc -c add.c -o add.o
gcc -c sub.c -o sub.o
#第二步
gcc main.o add.o sub.o -o math.exe
#第二步等价于
gcc *.o -o math.exe
~~~

### 5.1   makefile编辑法

~~~makefile
#注释
#目标    依赖
#         	   正常形式
#math.exe:main.o add.o sub.o 
#	gcc main.o add.o sub.o -o math.exe
#main.o:main.c
#	gcc -c main.c -o main.o
#add.o:add.c
#	gcc -c add.c -o add.o
#sub.o:sub.c
#	gcc -c sub.c -o sub.o
#clean:
#	rm -f *.o math.exe
# 				高级形式
math.exe:main.o add.o sub.o 
	gcc *.o -o $@
%.o:%.c
	gcc -c $< -o $@
clean:
	rm *.o math.exe
~~~

