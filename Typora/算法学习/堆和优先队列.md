数据结构就是，定义一种性质，维护这种性质。(结构定义 + 结构操作)

堆：逻辑结构是一颗完全二叉树， 物理结构是连续数组

大顶堆中：第三大的值可能在第二层或者第三层，第四大的值在2，3，4层

弹出操作：最后一个元素移动与第一个位置交换，第一个位置向下调整，三元组中选择最大的放到头部，以一个临时指针来记录最终去哪个位置，如果指针没有发生变化，直接break；

**删除操作，最后一个元素与要删除的元素交换位置，先判断是否可以向上调整，不行再判断向下调整。**

插入操作：向上调整，与父节点对比

堆排序：从小到大的排序，那么需要一个大顶堆，每次将最大的元素与最后一个位置交换，再调整。 也就是N轮的弹堆操作(每次弹堆调整为logn), 时间复杂度N * logN



不准确的说优先队列是堆的别名，更准确来说堆是优先队列的一种实现方式

普通队列和优先队列的区别就是， 普通队列先进先出， 而优先队列每次出的都是最大或者最小值

priority_queue<int,vector<int>, less<>>得到大顶堆，其实意思就是在建堆的过程用less，排序完后得到一个大顶堆

~~~c++
#include <bits/stdc++.h>
using namespace std;
#define MAX_N 1000
int arr[MAX_N + 5], cnt = 0;

void push(int x) {
    arr[cnt ++] = x;
    int idx = cnt - 1;
    int tmp = arr[idx];
    while(idx > 0 && arr[(idx - 1) / 2] < tmp) { //idx>0则一定有父，因为以0为下标开始的
        arr[idx] = arr[idx / 2];
        idx = (idx - 1) / 2;
    }
    arr[idx] = tmp;
}
int size() {
    return cnt;
}

void pop() {
    if(size() == 0) return;
    arr[0] = arr[cnt - 1];
    int tmpval = arr[0];
    int idx = 0;
    cnt --;
    while(idx * 2 + 1 <= cnt - 1) { // 保证一定有左子节点
        int tmpidx = idx;
        if(arr[idx * 2 + 1] > arr[tmpidx]) tmpidx = tmpidx * 2 + 1;
        if((idx * 2 + 2) <= cnt - 1 && arr[idx * 2 + 2] > arr[tmpidx]) tmpidx += 1;
        if(tmpidx == idx) break;
        arr[idx] = arr[tmpidx];
        idx = tmpidx;
    }
    arr[idx] = tmpval;
}

int top(){
    return arr[0];
}

int main() {
    int op, val;
    while(cin >> op) {
        switch(op) {
            case 1: {
                cin >> val; push(val);
            }break;
            case 2: {
                cout << "top:" << top();
                pop();
            }break;
        }
       
    }

}
~~~

剑指offer40，最小的k个数