## 多reactor模型设计

### 前置知识

1.如果B进程继承了A进程的listenfd(也就是说先创建listenfdfork出来B进程)，虽然A、B进程有独立的文件描述符表，但listenfd这一表项指向的内核资源是同一个

2.(如果fork之前执行epoll_create)也是和第一点同样的道理，进程的底层内核资源epoll是同一个。

3.epoll和listenfd都是文件描述符，并且它们都是内核资源(也就是说fork出来的进程尽管在用户态有独立的地址空间，但内核资源都是同一份)，epoll文件描述符比较特殊专用事件通知机制。

### 情景分析

#### 第一种（非多reactor，无惊群）

~~~shell
执行顺序bind->listen->epoll_create->fork(listenfd需要在fork之前加入epoll，因为父子进程的listenfd和epoll的底层资源是同一个，这种情况创建的listenfd无法在fork之后多次添加到epoll中，所以必须在fork之前)，并不是多reactor模型，也没有惊群现象 # 我是这么理解它没有惊群现象的(所有进程共用同一个epoll(内核资源层面)，也就是说他们底层是同一个双向链表，内核使用锁机制确保对双向链表(共享资源)的同步访问，所以不会有惊群问题。
~~~

情景演示：child进程接收了新连接fd为5，但断开连接(ctrl+c)的时候却是parent进程处理的，两个进程虽然有独立的资源映射表，但指向的内核资源是同一个

![1718259755326](../../pic\1718259755326.png)

#### 第二种（多reactor，但有惊群现象）

~~~shell
只设置SO_REUSEADDR不设置SO_REUSEPORT，先listen，接着bind，fork之后再逐个进程执行epoll_create，然后在每个进程中都把同一个listenfd放进去，那么这个时候就有惊群现象因为它们的监听队列是同一个，其中一个进程能成功accept，其余的会返回-1. 此时就算设置SO_REUSEPORT也不能避免惊群现象，其实这里提到SO_REUSEPORT只是幌子，它的作用只是能对同一个ip+port重复调用bind函数，因为有地方说SO_REUSEPORT使得多个进程有独立的监听队列，但跟这里没关系，当前说的这种情况下本质上只执行了一次bind，所以只有一个监听队列，是否用SO_REUSEPORT都没有影响 # 我是这么理解它的惊群现象的，此情况下内核创建了两个epoll资源，也就是两个双向链表，epoll底层的触发机制是，如果有事件则会通知监听这个事件的所有进程，如果第一个进程处理的时机较早(调度顺序进程取决于内核无需关心)直接就把listenfd触发的事件处理完了，当第二个进程被唤醒的时候，去查看自己的双向队列发现没有事件了(因为两个进程的listenfd的底层内核资源是同一个，其中一个进程处理了，第二个进程就自然看不到了)，于是就会继续阻塞(epoll_wait的设计本就是没有事件的时候就等待，所以不用纠结为什么被唤醒了却没有直接返回0)，所以这个惊群现象并不是必现的，取决于进程尝试去处理事件的时机)
~~~

#### 第三种（多reactor，无惊群）

~~~shell
给listenfd注册EPOLLEXCLUSIVE事件，能保证只有一个进程被唤醒去处理连接请求(理论上不设置这个标志则事件触发时会尝试通知所有关注这个事件的进程)，但这样的问题就是连接的效率被限制了，同一个时刻只有一个进程在处理连接，亲测连接请求分布不均匀，可能一直是一个进程在处理
epoll_event event;
event.data.fd = listenfd;
event.events = EPOLLIN | EPOLLET;
event.events |= EPOLLEXCLUSIVE
~~~

#### 第四种（多reactor，无惊群，多监听队列）

~~~shell
使用reuseport的特性，这次一开始就直接fork进程，然后在每个进程中分别按序执行bind,listen,epoll_create，再把这个listenfd加入到epoll中，此时执ss -ltn 可以看到创建了几个进程就有几个监听同一端口的套接字。
~~~

####  拓展：前提是不用epoll，只有accept

~~~shell
(根本不涉及nginx的accept锁的概念，但如果引入了epoll，nginx网络模型的accept锁是必须的)，比如bind后进行fork，每个进程(包含父)都同时while(1)只调用accept函数，操作系统保证只有一个进程去accept，其余的进程都不会有惊群现象，也就是说其余的进程并不会出现accept失败继续执行之后代码的情况 # 我是这样理解的，跟第一种类似，所有进程在内核层面共用了同一个监听队列，内核使用锁机制确保对监听队列(共享资源)的同步访问，所以不会有惊群问题。
~~~

SO_REUSEPORT和SO_REUSEADDR分析

~~~shell
SO_REUSEADDR: 不允许同一个端口被重复bind，解决的问题只有一个，比如一个进程杀掉之后会进入TIME_WAIT状态，此时重启这个进程会报错Address already in use, 原因是因为新程序如果直接用这个端口可能收到旧的数据包（比如四次挥手的时候失败了重传第三次挥手），使用这个标志可以避免这个报错，但如果用的不合理的话还是有收到旧数据的可能。
应用场景：同一个相同功能的进程，想要快速重启，避免等待

SO_REUSEPORT: 允许同一个端口被重复bind，它其实已经包含了SO_REUSEADDR的功能，现代编程中两个标志都用的原因是为了增强程序的兼容性和可移植性。(因为有些系统可能要求必须用SO_REUSEADDR)

场景举例：
如果是先bind了，再fork进程(本质上没有再次bind的步骤，都是直接继承的父进程)，不管是否使用SO_REUSEPORT，所有进程都会共用同一个监听队列(通过ss -ltn可以看到只有一个监听套接字)，用SO_REUSEPORT的好处是，如果多次调用bind可以成功，比如同一个进程，你可以开三个相同的实例绑定在同一个端口，那么这个时候同一个端口就有三个监听队列，由操作系统进行负载均衡决定一个新的连接放到哪个监听队列中，可以使用telnet ip port/nc ip port来模拟tcp的连接请求测试服务。
~~~

