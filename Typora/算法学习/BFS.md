先定义状态(struct Data{} )， 三个步骤，入初始状态， 拓展状态， 出状态



用于记录状态的方式：新开一个数组来记录，或者用unorderd_set, 根据情况来选择用哪种，让你最后返回一个数组一般就用数组的方式，若只是记录状态就unordered_set, unordered_set的适用场景更广

可以把二维数组转化为一维的状态，x * m + y ,  x,y是坐标，n 是行， m 是宽，用unordered_set来记录是否走过这个数组的这个位置，比如3行4列， x,y 为 2,1, 那么转换出来的坐标就是6。

993(堂兄弟节点，DFS,BFS) ，

~~~
核心就是给两个全局的父节点指针，再用两个k分别记录深度，最后不管是DFS还是BFS结束，比较指针和k就知道结果了
~~~



542（01矩阵BFS）

~~~
1.二维数组也可以直接拷贝构造的方式构造。
2.开始把所有0都入队列了，所以只要是能被遍历到的1的位置都一定会在第二层之前遍历， 不用担心这种情况
0 0 0
0 0 1
1 1 1   不用担心3行2列的这个1是被它左边的1扫描过来的，因为它左边这个1被加入队列的时候已经是第二层次的节点了
~~~



 752(打开转盘锁，用unorderd_set进行状态去重)，

 1091(最短路径，八个方向)，

 剑指13机器人的运动范围：用unoredered_set状态去重，二维转一维

