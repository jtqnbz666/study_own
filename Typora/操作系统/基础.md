计算机怎么存小数

```shell
前置知识: 十进制转二进制: 整数部分除2取余逆序数处， 小数部分乘2取整正序输出
						10.625(10进制) == 1010.101(2进制)
1. 并不是所有的小数部分都能用二进制表示， 比如0.625就可以， 但0.1是一个无限循环的二进制，只能用「近似值」来表示，所以就会造成精度缺失。
2. 以float为例，32位中，第一位是符号位，接着的8位是指数位，最后的23位是尾数位。
其中指数位计算中的移动位数说的是比如1010.101对于计算机必须用科学技术法也就是1.010101 * 2^3, 那么移动位数就是3(如果是右移就是-3)
3. 0.1 + 0.2 != 0.3 只能是0.3的近似值，因为0.1和0.2在计算机存储的时候存的也是近似值

# 比如36.6
36 的二进制表示是 100100。
0.6 的二进制表示是 0.10011001100110011001100...（循环小数）
合起来为1.00100100110011001100110... × 2^5， 阶码(移动位数)为5，但在IEEE 754标准中，阶码要加上一个偏移量（127），所以是132。
符号位：0
阶码：10000100
尾数：00100100110011001100110 （取小数部分的前23位）
将上述三者拼起来为
0100 0010 0001 0010 0110 0110 0110 0110 # 16进制为0x42126666

```

![image-20240402170239243](E:/study_own/pic/image-20240402170239243.png)

加减乘除效率分析

```shell
加法：是最简单和最快速的运算,CPU中有专门的加法器件用于执行加法操作。
减法：可以通过将减法转换为加法来实现，效率也不错
乘法：比加法和减法复杂，耗费的时间较多，特别是对于大整数或浮点数的乘法运算。
计算机硬件会使用乘法器件来执行乘法操作，这个过程比加法要复杂，耗时相对较长。
除法：是四则运算中最复杂和耗时最长的运算，计算机硬件中通常没有直接的除法器，实际上除法操作会通过多次的减法和移位来实现，因此除法操作通常比较耗时。

# 计算机并不是不能用减法，只是为了简化硬件设计和电路的复杂性，才用加法器来做减法运算
# 假设有减法器计算 1 - 2
  0000 0001  (1)
- 0000 0010  (2)
------------
  1111 1111  # -1的补码形式(计算机的计算结果都是补码形式, 正数的补码和原码一样)
# 使用加法器计算减法
  0000 0001  (1)
+ 1111 1110  (-2的补码)
------------
  1111 1111  # 跟减法器一样的结果
# 补码形式计算减法 2 + (-1)
  0000 0010  (2)
+ 1111 1111  (-1的补码)
------------
 10000 0001	 # 第八位是符号位(不管第九位了)，为0则说明是正数
 
拓展:
补码的好处:简化运算(只需要加法器，简化运算逻辑和硬件设计)、统一表示形式(加减运算都用补码的形式, 不用额外考虑负号位)
```

ELF文件

~~~shell
1. 编写的代码，首先通过「编译器」编译成汇编代码，接着通过「汇编器」变成目标代码，也就是目标文件，最后通过「链接器」把多个目标文件以及调用的各种函数库链接起来，形成一个可执行文件，也就是 ELF 文件。执行 ELF 文件的时候，会通过「装载器」把 ELF 文件装载到内存里，CPU 读取内存中的指令和数据，于是程序就被执行起来了。
2. window中可执行文件叫PE(拓展名通常是.exe, .sys等)
3.linux是宏内核， window是混合内核
宏内核，包含多个模块，整个内核像一个完整的程序；
微内核，有一个最小版本的内核，一些模块和服务则由用户态管理；
~~~

**用户态和内核态**：

- **用户态**：用户态是程序正常运行的地方，用户进程在这里执行。用户态不能直接访问硬件，也不能直接访问内核态数据结构。
- **内核态**：内核态是操作系统核心代码运行的地方，能够直接访问硬件和内存，并可以执行特权操作。系统调用（如 socket、epoll 等）将用户态进程的请求传递到内核态处理。

**内核资源**：

文件描述符(比如epoll 和 listenfd )都是内核资源，当你调用 `epoll_create` 时，内核会在内核态创建一个 epoll 实例，并返回一个文件描述符（epoll 文件描述符），epoll 实例的实际数据结构（如红黑树和双向链表）存在于内核态，监听套接字（listenfd）也是由内核管理的资源，用户态进程通过文件描述符与这些内核资源交互。

**DMA**

~~~
设备分为块设备和字符设备，比如鼠标每次点击都会触发硬中断通知cpu进行中断处理，而块设备比如磁盘触发中断的次数会很频繁(块设备因为数据交互量比较大所以有一块缓冲区)，影响CPU的效率(因为中断的成本是比较高的，涉及上下文的切换)，所以有了DMA，CPDU直接对DMA控制器编码告诉它需要哪些数据以及放到哪，DMA控制器进一步控制磁盘的设备控制器，磁盘的设备控制器负责把磁盘数据放到块设备的缓冲区，DMA负责把块设备缓冲区的内容进一步放到指定的内存区域，DMA处理完所有数据后触发中断告诉CPU可以去拿数据了
~~~

![1718471588700](../../pic\1718471588700.png)

**设备控制层次**

~~~shell
分为块设备和字符设备，块设置由于数据交互量大设立了单独的缓冲区，有三个主要概念，设备、设备控制器、驱动程序，设备由设备控制器进行控制，设备控制器有独立的寄存器(命令寄存器、数据寄存器、状态寄存器)，设备控制器又由设备的驱动程序来屏蔽设备的差异，比如鼠标是由鼠标控制器控制的，但有不同品牌的鼠标，通过鼠标的驱动程序来屏蔽不同品牌鼠标的差异。

# 简言：驱动程序属于内核部分内容，设备控制器属于硬件层面的内容，驱动程序(鼠标类、键盘类)屏蔽了不同类别设备差异(镭射鼠标、联想鼠标)，通过操纵设备控制器进一步控制设备。
~~~

**零拷贝（发送文件举例）**         

~~~shell
基本做法不使用零拷贝技术，先把数据从磁盘read出来，再write到网卡发出去，此过程发生了4次用户态与内核态的上下文切换和4次数据拷贝
~~~

![1718471640592](../../pic\1718471640592.png)

零拷贝技术实现的方式通常有 2 种（mmap + write和sendfile ）        

mmap+write

~~~shell
buf = mmap(file, len); # read换成mmap
write(sockfd, buf, len);
mmap()被调用后，DMA会把磁盘的数据拷贝到内核的缓冲区里，接着会直接把内核缓冲区里的数据映射到用户空间，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作，相比之前用read减少了一次数据拷贝，但还是4次上下文切换(有两个系统调用函数)
~~~

![1718471799405](../../pic\1718471799405.png)

sendfile

~~~shell
2次上下文切换，和 3 次数据拷贝
~~~

![1718472096342](../../pic\1718472096342.png)

sendfile(网卡支持SG-DMA技术的情况下，只有两次数据拷贝操作)  

![1718472260933](../../pic\1718472260933.png)

零拷贝技术的应用

~~~shell
kafka和nginx都用到了零拷贝技术，大幅提升了I/O的吞吐率，这也是为什么kafka处理海量数据这么块的原因之一
~~~

大文件传输场景

~~~shell
不会使用零拷贝技术，因为零拷贝技术中DMA会把数据放一份到PageCache（内核缓冲区，也就是磁盘高速换成）中，本来这块区域就是为了提升命中率避免访问磁盘，但大文件的情况下就根本用不上，还会因为把大文件的内容放到上边从而影响小文件的命中率导致磁盘I/O增多，所以大文件情况下采用异步I/O（DMA直接把数据从磁盘控制器缓冲区拿到用户缓冲区，不经过PageCache）

# 绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。
# 另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化： 内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「合并」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；内核也会「预读」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；
~~~

![1718473168524](../../pic\1718473168524.png)

零拷贝总结

~~~shell
1. 传输大文件的时候，使用「异步 I/O + 直接 I/O」；
2. 传输小文件的时候，则使用「零拷贝技术」
~~~

