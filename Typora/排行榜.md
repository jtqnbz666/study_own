线上操作

~~~
1.24461名玩家执行了3分钟（从mysql读玩家数据再尝试上榜，9w玩家花了10分钟
~~~





### 36.排行榜

尽管是海量数据， 榜单有监测范围，也是可以解决的

之前排行榜的问题：

~~~
遇到两个case
1.刷榜时redis存了一个脏数据，但mysql那边又给删掉了
2.刷榜时需要删缓存，uds的流程是1.取出数据，2.执行操作，3.回写数据， 如果删缓存的操作在2的时候进行，则会回写脏数据，比如锦标赛榜会取缓存的值进行+1则有问题

问题1的本质原因是，1.数据存在了两个地方(mysql和redis) 2.操作同一个key 3.lbs和uds分开可能有时间差的影响，
问题2的本质原因是，榜单涉及到的数据跟其他业务有耦合

问题1的可解方案: 不同榜单周期用不同的key名，一开始就计算出应该上榜哪个key名
问题2的可解方案: 对mysql表加锁。  可优化地方是: 减小操作力度，1. 删除数据的操作在玩家登录的时候触发，只处理榜单玩家和在线玩家, 2. 或者在线由前端主动请求， 不在线玩家下次登录时触发。
~~~

需要考虑的问题:

因为前端的请求是有用户锁的， 所以不用考虑多线程操作同一玩家数据的情况， 但是定时任务会出现同时操作玩家数据的情况，这种数据竞争问题一般的做法是选择加锁。

改进思路：

1. mysql干掉,迁移mysql数据到redis(榜单数据)，2. redis,(配合zset,hash)不同周期用不同key, 3. lbs合并uds, 4. 注意多节点下单任务执行(setnx设长一点, ) 5. lbs内存缓存不要了

英雄榜更新时机:1.ttf变化时，2.英雄信息有变化时(结算/赛季更新/定时任务)， 

需要考虑如果玩家没有的英雄不参与排行榜的计算

如果是存在mysql的数据，就不用放到redis的hash中了。

当前计划: 涉及到UserHeroList变化的都用wrapdataprocess包起来，避免和User(主要避免ttf的变化)在一块

需要注意的:

检查异常捕获

登录时不需要尝试上榜，但需要更新下英雄的ac

赛季更新会自动尝试刷新英雄榜和竞技榜

收藏榜不要做成只增的，如果11点同时两个请求发送过来还是可能脏数据，兜底做法是清除数据的时候查看当前榜单是否有自己，如果有，就删掉自己

暴击榜/锦标榜/巨灵榜，先取再加值，取key1，那也写key1，取key2，写key2

英雄榜/竞技榜不做处理，因为赛季切换的时候会以新值重新上榜

赛季切换感觉可以弹到主界面

赛季榜是前端触发的，所以uds不存在回写缓存的问题， 周期榜是一个定时任务，所以有回写的问题。

巨灵榜用zset+hash，感觉锦标/暴击榜都用不到hash， 赛季榜就只用一个zset，数据还是放在mysql

ttf放在mysql，不动

只load是不会回写数据的

活跃系数因为在不断变化，可以实时算出需要的结果，可以不放在mysql，如果实时算有压力再考虑使用缓存，但也不至于永久存到mysql

加锁，30s定时任务刷ac的时候获取玩家锁





需要整理有哪些数据需要从mysql拿到redis，比如石灵等级，ttf等

跨赛季登录的问题

会清空的榜单(锦标，暴击，巨灵，收藏)，会继承的榜单(竞技榜，英雄榜)

更新英雄战力时机

~~~
所有英雄: 1.登录的时候， 2.点击个人主页的时候，3.ttf变化时，4.赛季结算时 5.定时器更新监测范围的玩家。 
单个英雄：1.结算时更新活跃系数
~~~




### 知识点

6.获取榜单玩家基础数据的时候用pipeline的方式，能极大减少访问redis次数

5.数据更新规则

~~~shell
排行榜数据更新规则: 1. 取原值进行对比，如果大于则覆盖(暴击榜) 2. 直接覆盖(如果和原值一模一样则不能覆盖，因为score拼了时间戳，可能掉排名)(英雄/竞技榜)

玩家记录数据更新规则: 1.在原值基础上+1(锦标榜) 2.跟原值做对比，如果大于则覆盖(暴击榜) 3.直接覆盖(竞技榜)

# 二者的区别:前者为上榜规则， 后者为数据记录规则
~~~

4.redis排行榜更新时最好不用清榜操作，而是每个周期的榜单用一个单独的key(用日期拼)，然后再手动或者expire上个周期的key,  这样的好处是 1. 减少多节点操作可能出现的redis处理时序问题，比如A节点先处理完清榜操作，与此同时B节点有一条清榜前的上榜请求就出现了脏数据。2. 保留一段时间上个榜单周期的数据    

思考: 就用同一个key，但上榜的时候检查下时间看是否是本周期的榜单可以吗？

~~~
我觉得不可以， 因为key名没有拼接时间信息，不知道当前key是哪个周期的，所以最好还是不同周期用不同key名。
~~~

3.在2的基础上

~~~
2保障了score的准确， 但是member却不好控制， 如果member用"uid_其他信息", 但zset不支持通过uid模糊查询， 所以这里可以再用一个map<uid,member>的映射， 找到具体的对象，如果信息改变了，删除member，用它的score新建一个member-score
~~~

2.分数相同时间用基准值实现先到的排在前边

~~~
zsetScore = 玩家游戏分 + ((基准时间 - 玩家获得某分数时间) / 基准时间)，就实现了分数相同，先达到该分数的排在前面的功能。
这样就能以uid作为member， 最终的score取zset里存的value的整数即可， 比如上边的zsetScore算出来是666.66， 那么取整数666就是自己最初的得分
~~~

1.如果分数一样，会用member的字典序，因为zset的value不支持复杂类型数据结构, 所以可以key做调整

~~~c++
ZSET leaderboard
"1637081601_10001" => 666
"1637081602_10002" => 666
按字典序。"1637081601_10001"排在前

问题: 无法通过uid拿到分数， 因为不知道时间戳

注意: zset的member对应的score不能是字符串, 只能是float

~~~

### 
