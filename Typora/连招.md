### 问 ：点击url发生的事情：
解析url，得到web服务器名称和文件名， 生成http请求消息(延展get， post方法)，DNS解析域名地址(拓展迭代法和递归法)，arp协议细讲

### 问：静态对象的用处，或者 单例模式的好处()

1.先介绍静态对象的位置，生命周期，不同文件没有命名冲突，extern无法访问

2.延展pthread_create,  必须使用静态函数原因，因为非静态函数有this指针，参数不一致，如果是全局函数，则破坏了类的封装性(谈到封装性可以扯c++中的**友元**)。 既然必须是静态函数，那么怎么访问类中的非静态成员呢，也就是pthread_create的第四个参数如何设置，有两种方式，**第一种**是传入一个pthis指针(这个pthis是一个静态指针，在对象构造函数初始化的时候设置pthis = this)，或者直接传nullptr(使用单例方式的方式得到全局访问点)，有点像MFC中获取主窗口的方法，但如果是多个实例对象，这种方式就不可行了， **第二种**方式就是建立一个静态hash表，类中有一个静态成员m_sid  和一个普通成员 m_id 以及这个静态hash表，每个对象维护自己的m_id(构造函数初始化的时候，**值为当前静态hash表元素的个数+1**，所以我们是可以知道m_id的值的，可以给它记录一下), 第四个参数每次传入一个需要的对象的m_id 赋值给m_sid,就能通过这个静态hash表找到对应的this指针对象。

3.static(因为没有this指针)和const(构造函数需要修改成员值，但const表示不能修改，并且const成员必须用初始化参数列表的方式来初始化，不能在构造函数中赋值)都不可以用来修饰构造函数或者析构函数

4.扯空指针对象可以调用普通函数，必须要有对象才有虚表，所以不能把构造函数弄成虚函数，通过虚表访问虚函数, 同一个类的所有对象的虚表都是一样的。vs打印c++类的分布查看虚表结构，多继承的虚表不止一个(前提是基类有虚函数)
基类和子类各自有不同的虚表，**如果是基类指针指向子类对象，那么这时使用的是子类的虚表**。

5.单例模式先介绍什么是单例模式？ 保证任何情况下都只有一个实例，就像上边说的因为如果是static修饰就可以在不同文件中出现多个实例对象， 所以这个static 单例对象不能是全局的，为了保证它不是全局的，必须给类的**构造函数设置为私有的**，此时只剩下一种方式能调用类中方法，那么就是静态函数的方法，但static函数只能访问static对象，所以必须要在类中定义一个static对象这就是单例模式唯一实例必须设置为静态的原因。
1.介绍懒汉饿汉， 2.doublecheck加锁细节，3.如果是指针对象，必须要加一个静态函数进行资源释放

6.类中的静态成员在编译时就确定好了， 而类中的函数中的局部静态成员是在第一次调用的时候才创建的对象(可以用普通局部对象的思维来理解)。



## 问const

const修饰类的成员变量，表示成员常量， 不能被修改，并且只有两种初始化方式，要么直接 const int a = 5; 要么不赋初值，但必须使用初始化参数列表的方式初始化。

**类中的同名函数，一个加const一个不加可以存在**，但无法重载两个同名但不同类型的函数，比如 int test(); 和 void test() 不能同时存在，但 int test(); int test() const可以同时存在。

const对象只能调用const函数

非const对象调用优先调用非const函数

const函数里面只能调用const函数。非const函数可以调用const函数

const函数如果在类外定义，必须加上const修饰，而static变量或者函数就可以不用加static。

const*  和  *const 区别。

参数列表加const的好处，不加之前只能传入左值，加了const就可以传右值，还可以使用const_cast转换去掉const属性

### 问：I/O多路复用

1.先解释I/O复用是什么意思

2.select，poll， epoll(ET(边沿触发)必须是非阻塞, LT(水平触发)) 

3.多线程访问同一个fd问题， epoll_oneshot

4.阻塞和非阻塞区别，如果connect使用非阻塞的方式，怎么来判断是否成功，判断第一次write事件(因为connect无论成功与否都会触发write事件)，通过getsockopt来获取错误码，如果没有错误码则表明connect成功，反之使用重连机制重新连接

select：能监听1024个文件描述符(本质上是一个long类型的数组，大小为16)，监听三种事件(并且注册事件的时候只能一个一个注册)，轮询所有fd，并且每次select都需要重写注册事件，因为位图被打乱了。

![1676210361901](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1676210361901.png)

poll: 不限制描述符数量，可以监听多种事件(按位与的方式)，轮询所有fd，相当于高效的epoll:不限制描述符数量，可以监听多种事件(按位与的方式)，只处理发生的事件，底层是红黑树和双向链表。



3.扯统一事件源， epoll_wait最后一个参数，定时器设计

**4.同步IO， 异步IO模型：**与同步异步的区别， 分析适用场景，延展Reactor(write, read)，Proactor(aio_read, aio_write，这两个接口会告诉内核读写缓冲区的位置，全部操作由内核完成，直接向内核注册的是**读完成事件**， 而Reactor中注册的是**读事件**)

**5.惊群问题**：对于accept的惊群，内核2.6已经解决了， 对于epoll_wait的惊群问题，设置epoll事件中的EPOLLEXCLUSIVE模式，保证每次只唤醒一个epoll_wait, 和EPOLL_ONESHOT(保证事件只促发一次，防止多线程对同一个fd进行操作)有点类似，为什么只保证了accept，而epoll_wait让用户自己选择， 因为accept只针对listenfd，而epoll_wait还要监听各种fd。

区分一下两种不同的情况(这两种情况,目前linux内核都有处理的办法)。

1. 多个进程/线程使用同一个epfd然后调用epoll_wait     //memcached 多线程
2. 多个进程/线程有自己的epfd,然后监听同一个socket   //nginx  多进程

Redis 采用的是 单 Reactor 单进程的方式，Memcache 采用的是 多 Reactor 多线程的方式，Nginx 采用的是多 Reactor 多进程的方式

通过memcached网络模型和Nginx，引出我自己的进程池模型，所有进程都listen了listenfd(也就是继承了父进程的状态)， 但只有父进程把listenfd放到了epoll_wait中监听， 当收到listenfd信息后，父进程通过负载均衡以管道的	方式将命令发送给子进程进行accept处理（每个子进程都有自己独立的epfd)

```
对于nginx是先fork,再调用epoll_create,各进程独享自己的epfd。

Nginx 目前有几种方法解决惊群问题：
accept_mutex
如果开启了accept_mutex 锁，每个 worker 都会先去抢自旋锁，只有抢占成功了，才把 socket 加入到 epoll 中，accept 请求，然后释放锁。accept_mutex 锁也有负载均衡的作用(为了保证每个进程的任务量均衡，具体实现就是判断一个值是否足够大，如果是，就不去尝试获取锁，并且每次将这个值减一)。
为了减少单个进程长时间占据accept，
导致其他进程无法接受新连接，应该尽量减少accept锁的占据时间， nginx采用了 NGX_POST_EVENTS 标志位，如果获取到了锁，就把事件(accept事件，普通事件)放到两个队列中延迟处理，然后先去处理accept事件的那个队列，然后立即释放accept锁，再去另外一个普通事件的队列。

EPOLLEXCLUSIVE
EPOLLEXCLUSIVE 是 Linux 4.5+ 内核新添加的一个 epoll 的标识，Nginx 在 1.11.3 之后添加了 NGX_EXCLUSIVE_EVENT。EPOLLEXCLUSIVE 标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多个进程监听下的“惊群”问题。不过任一时候只能有一个工作线程调用 accept，限制了真正并行的吞吐量。

SO_REUSEPORT
SO_REUSEPORT 是惊群最好的解决方法，Nginx 在 1.9.1 中加入了这个选项，每个 worker 进程都有自己的 socket，这些 socket 都 bind 同一个端口。当新请求到来时，内核根据四元组信息进行负载均衡，非常高效。
```

这里需要注意，我写的**只有主进程**才会把listenfd放到监听队列中

 但内核3.9开始，给socket提供了SO_REUSERPORT特性，可以让不同的socket绑定在同一个端口上，那么我们可以让每个线程都有一个socket(绑定在同一个端口)，在accept的时候，内核会自动处理惊群问题。
可以这么理解，现在有多个socket(绑定在同一个端口上)， 当有连接信息过来的时候，内核负载均衡的选择其中一个，那么只有这个socket对应的epoll_wait才会触发，自然也就解决了epoll惊群问题，更不会有accept问题

EPOLLEXCLUSIVE模式和SO_REUSERPORT都能解决惊群，但SO_REUSERPORT使用的更多，性能更好



### 问：hashmap

哪些重要属性：1.size已经存储的节点个数， 2.threshold 扩容阈值， 当hashmap的个数达到该值时，触发扩容， 3.loadfactor：负载因子，扩容阈值=容量 * 负载因子

考虑时间和空间的权衡，链表转红黑树的阈值是8(如果达到9，并且此时数组长度>=64会发生转化)， 红黑树转链表的阈值是6，如果都是8，很容易转来转去

扩容机制：比如数组大小是4，一个数据通过hash得到的值是6 (110)，那么取余后为2，此时若对数组扩容变为8， 则用刚才的6 & n-1 即 (110 & 111) 只用判断第一位相&后是否为1， 若是，则6在新的扩容数组的下标为原来的下标(2) + 原来的数组大小(4)  = 6；

缩容机制同理： 比如现在数组大小为8，当前索引位置为6(110), 需要缩容到4(100), 则将6 & 2^n (即是4) ，看第一位是否为1， 若是则新位置为原来的位置(6) - 缩容后的数组大小(4) = 2;

rehash方法，需要一个**指针**， 每次获取值的时候，先hash得到索引，判断这个索引大小是否比这个**指针**的位置大， 若是则在原来的hash数组中找， 反之去新数组找， 同时将原来的数组的**当前指针**位置数据更新到新数组中去，将**指针**往后移动一位，直至完全rehash

**拓展：**key-value存储原理，

redis中的字典结构， 字典结构包含的主要属性有，rehash指针， 迭代器，两个哈希表(每个hash表的主要属性包含，具体的table(数组)，总容量，已经使用的大小)，一般只使用第一个hash表，除非需要rehash的时候会使用两个，rehash完毕释放不要的那一个，把第一个hash表指向需要用的那一个(这也就是为什么一般只用第一个hash表)，扩容缩容一样的原理。

哈希冲突，开放地址，公共溢出区，拉链法， redis中采用的是拉链法，每个哈希位置都有一条链表，链表的元素类型为dictEntry(包括了key和value的值以及下一个节点的指针)， 比如现在key1和key4发生了冲突，那么在hash表的同一个位置上的这条链表上就有两个元素，一个是(key1, value1，它的next指针就指向key4), 另一个是(key4,value4), 

再谈字典中的迭代器， 它的作用其实就是遍历hash表，迭代器的主要字段包括，当前正在迭代的字典，正在迭代的hash表的号码(0或1)， 正在迭代的hash索引位置， 具体的这个hash节点的指针，以及是否是安全迭代器(如果安全可以对字典进行修改，反之不行)

拓展： hash聚集，链表法存在hash聚集问题， 开放地址法也只是将hash聚集延后了， 本质上解它们可以使用双重hash的方法，具有强随机性

## 问操作系统

回答虚拟地址如何变到物理地址(MMU)， 讲页表主要项，多级页表机制， DMA机制， TLB机制
延展，缺页异常情况如何处理， 扯free命令中的buffer/cache, 扯malloc分配机制

## 问构造函数

1.发生构造函数的情况 

2.类的对象初始化顺序(先构造函数的参数，再成员，最后构造函数里面的实现) 

3.移动构造和移动赋值的优势， 为什么不能用移动构造和移动赋值来代替拷贝构造和拷贝赋值(因为场景需求不同，有时候我们就需要有两份数据，就必须要拷贝构造函数) 。

4.为什么要把拷贝构造函数的参数设置为&(以防循环构造问题)，以及为什么需要设置为const(const能保证既能传递左值也能传递右值)
这里引申move失效问题(如果没有移动构造函数， 此时尽管是右值，但也是调用的拷贝构造函数)。

~~~c++
A a;
A b(move(a));  //move(a) 相当于一个右值了


如果没有移动构造函数，并且拷贝构造函数参数没有加上const， 则会报错，这也就是为什么一般拷贝构造函数也要加上const。
~~~

5.RVO优化情况(A a = getA()) 优化为去掉返回值，变成getA(&a)的方式。这里解释以下汇编的原理。