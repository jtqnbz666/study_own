## 1.普通文件
		### 1.1父子进程可以通过文件描述符号

#### 代码展示(fd)

~~~c
//file.c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
/*
	用来演示父子进程间通过文件进行通信

	父进程写，子进程读

	*/
int main()
{
	int fd=open("a.dat",O_RDWR|O_CREAT,0666);
	if(-1==fd)printf("创建文件失败：%m\n"),exit(-1);
	printf("创建文件成功！\n");
	close(fd);
	if(fork())
	{
		
			int n=0;
			while(1)
			{
				int fd=open("a.dat",O_WRONLY);
				write(fd,&n,4);
				close(fd);
				sleep(1);
				n++;
			}
		 
	}
	else
	{
		int m;
		while(1)
		{
			sleep(1);
			int fd=open("a.dat",O_RDONLY);
			read(fd,&m,4);
			printf(">>%d\n",m);
			close(fd);
		}
	}
	return 0;
}
~~~



​		### 1.2非父子进程之间就只能通过具体文件来通信
## 2.文件映射虚拟内存  mmap

实现功能：使用空格键来暂停和开始。

#### 代码展示mmap

~~~c
//mmap.c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/mman.h>
/*
	用来演示父子进程间通过文件进行通信

	父进程持续不断输出些什么
	子进程持续不断接受用户输入 
		输入 空格	停止父进程循环	输入回车 	父进程循环继续

	*/



int main()
{
	int fd=open("mmap.dat",O_RDWR|O_CREAT,0666);

	ftruncate(fd,4);//修改文件大小

	int*p=(int*)mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
	if((int*)-1==p)printf("mmap error:%m\n"),close(fd),exit(-1);
	printf("mmap ok!\n");

	*p=0;
	if(fork())
	{
		int n=0;
		while(1)
		{
			while(*p);
	
            printf("*p:%d n:%d\n",*p,n++);
			sleep(1);
		}
	}
	else
	{
		int n=0;
		char ch;
		while(1)
		{
			read(0,&ch,1);
			if(ch=='\n')//细节的很，字节回车就能实现暂停功能
			{
				n++;
			}
			if(n%2)
				*p=0;
			else
				*p=1;
			printf("子进程 *p：%d\n",*p);
		}
	}
	return 0;
}
~~~



## 3.有名管道(FIFO)
		### 3.1父子：匿名管道
​              3.1.创建文件描述符号  int   fds[2];
​             2.把文件描述符号变成管道    pipe
​             3.使用管道
​             4.关闭

有名管道本质上是内核空间的一段内存，没有文件信息，如inode，可以在没有亲属关系的进程间通信

#### 代码展示(匿名管道)

~~~c
//pipe.c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>

int main()
{
	//1.创建管道描述符号
	int fds[2];
	//2.创建管道
	int r=pipe(fds);
	if(-1==r)printf("创建管道失败：%m");
	printf("创建管道成功！\n");

	//3.使用管道
	if(fork())
	{
		char buff[1024];
		while(1)
		{
			scanf("%s",buff);
			write(fds[1],buff,strlen(buff));
		}
	}
	else
	{
		char tmp[1024];
		while(1)
		{
			r=read(fds[0],tmp,1023);
			if(r>0)
			{
				tmp[r]=0;//添加结束符号,不能缺少。
				printf(">>%s\n",tmp);
			}
		}
	}
	return 0;
}
~~~



### 3.2	非父子进程：有名管道（利用管道进行不同目录下文件的拷贝）
​		      			1.创建管道文件
​			A											B
2.打开管道文件						2.打开管道文件
3.往管道文件写入数据			3.往管道文件写入数据
4.关闭管道										4.关闭管道
​						5.删除管道文件  unlink

注意：

​		1.共享文件夹不能创建管道文件
​		2.打开管道文件的时候  只有  两边一起打开才会返回，只有一边打开会阻塞
​		3.先关闭读取端，会导致写入端进程结束；先关闭写入端，不对读取段造成影响。

#### 代码展示1(有名管道)创建和写部分

~~~c
//makefifoA.c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

int main()
{
	//1.创建管道文件
	int r=mkfifo("test.pipe",0666);
	//if(-1==r)printf("创建管道文件失败！：%m\n"),exit(-1);
	printf("创建管道文件成功！\n");
	//2.打开管道文件
	int fd=open("test.pipe",O_WRONLY);
	if(-1==fd)printf("打开文件失败！：%m\n"),unlink("test.pipe"),exit(-1);
	printf("打开管道文件成功！\n");
	//3.循环写入
	int n=0;
	char buff[1024]={0};
	int fd1=open("test.txt",O_RDONLY);//第二个文件
	int len=0;
	while(1)
	{
		int n;
		int r=read(fd1,buff,1023);
		if(r)buff[r]=0,printf(">>%s\n",buff);
			sleep(2);
		if((n=read(fd1,buff+len,(strlen(buff)-len)))==0)
		{
			printf("len=%d\n",len);

		write(fd,buff,strlen(buff));
			break;
		}
		len+=n;
		//write(fd,buff,strlen(buff));
		//sprintf(buff,"涛哥好帅哦！%d\n",n++);

		
	}
	close(fd1);
	//4.关闭
	close(fd);

	//5.删除管道文件
	unlink("test.pipe");
	return 0;
}
~~~

#### 代码展示2(有名管道)读部分

~~~c
//makefifoB.c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

int main()
{
	//2.打开管道文件
	int fd=open("test.pipe",O_RDONLY);
	if(-1==fd)printf("打开文件失败！：%m\n"),unlink("test.pipe"),exit(-1);
	printf("打开管道文件成功！\n");
	//3.循环读出
	int n=0;
	char buff[1024]={0};
	int r;
	int fd2=open("/media/sf_demo/guandao/test2.txt",O_RDWR|O_CREAT);
	if(fd2==-1)printf("创建文件失败！：%m\n");
	while(1)
	{
		r=read(fd,buff,1023);
		if(r>0)
		{
			buff[r]=0;
			printf(">>>%s\n",buff);
			write(fd2,buff,strlen(buff));
		}	
	}
	//4.关闭
	close(fd);
	close(fd2);

	return 0;
}
~~~



## 4.信号

借宿当前终端进程

ctrl+c		SIGINT
ctrl+\		 SIGQUIT

信号的处理过程
	进程A  在运行			内核  硬件  或者其他进程给进程A
	进程A接受到信号后
			1.直接做信号本身规定的对应处理
			2.做实现注册好的 信号处理
			3.屏蔽

linux提供的信号：64个
		不可靠信号（非实时）    unix提供的  1-31
		可靠信号（实时）		后来扩充 的     32-64

标准信号：操作系统提供的
自定义信号：用户自定义    	SIG_USR

信号注册
		signal

####  代码展示（普通信号：signal）

~~~c++
//signal.c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

void hand(int val)
{
	printf("val:%d\n",val);
	printf("想把老子干掉？没门！\n");
}
int main()
{
	signal(SIGINT,hand);
	printf("pid:%d\n",getpid());
	int n=0;
	while(1)
	{
		printf("n:%d\n",n++);
	return 0;
}
~~~



​		sigaction     不仅仅可以接收信号，做信号处理，还可以接收信号同时接收一些数据

![](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1639352471622.png)

#### 代码展示（高级信号：sigaction）

~~~c++
//sigaction.c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void hand(int n)
{
	printf("基本的信号处理函数！\n");
}

void handler(int n,siginfo_t* siginfo,void* arg)
{
	printf("高级的信号处理函数！\n");
	//printf("n:%d,msg:%d\n",n,siginfo->si_int);
	printf("n:%d,msg:%p\n",n,siginfo->si_ptr);
}
int main()
{
	struct sigaction act={0};
	struct sigaction oldAct={0};

	act.sa_handler=hand;
	act.sa_sigaction=handler;
	act.sa_flags= SA_SIGINFO;//SA_DEF系统默认,若是用现在这个用的是handler而不是hand

	//2==SIGINT
	sigaction(2,&act,&oldAct);//注册高级信号处理

	printf("pid:%d\n",getpid());

	int n=0;
	while(1)
	{
		printf("n:%d\n",n++);
		sleep(1);
	}

	return 0;

}
~~~



信号发送：
	kill命令   :				kill  -s 2  进程号
	kill函数

#### 代码展示（kill函数）

~~~C++
//kill.c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
int aton(char*str)
{
	int num=0;
	while(1)
	{
		num+=*str-'0';
		str++;
		if(*str=='\0')break;
		num*=10;
	}
	return num;
}

int main(int argc,char *argv[])
{
	int pid=aton(argv[1]);//字符串转整数
	int sig=aton(argv[2]);
	printf("---pid:%s,sig:%s\n",argv[1],argv[2]);
	printf("pid:%d,sig:%d",pid,sig);
	kill(pid,sig);
	return 0;
}
~~~



​	sigqueue:             union sigval联合体

![1639357354700](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1639357354700.png)

#### 代码展示（sigqueue）

~~~c++
//sigqueue.c
#include <stdio.h>
#include<unistd.h>
#include <signal.h>

int aton(char*str)
{
	int num=0;
	while(1)
	{
		num+=*str-'0';
		str++;
		if(*str=='\0')break;
		num*=10;
	}
	return num;
}

int main(int argc,char *argv[])
{
	int pid=aton(argv[1]);//字符串转整数
	int sig=aton(argv[2]);

	union sigval u;
	//u.sival_int =454193896;//四个字节的整型数据
	u.sival_ptr=0x666666;//传一个地址过去，该地址可以放很多东西。
	sigqueue(pid,sig,u);
	return 0;
}
~~~



信号集：
	sigset_t（结构体）

![1639391850085](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1639391850085.png)信号屏蔽：
	sigprocmask

#### 代码展示

~~~c
//sigprocmask.c

#include <stdio.h>
#include <unistd.h>
#include <signal.h>
void hand(int n)
{
	printf("基本的信号处理函数！\n");
}
int main()
{
	printf("%d\n",getpid());
	sigset_t set,oldSet;
	sigaddset(&set,2);
	//先五秒钟不设置信号屏蔽
	signal(2,hand);
	sleep(5);
	int ret;
	//设置信号屏蔽20秒
	if(1==sigismember(&set,2))
	{
		printf("设置信号屏蔽！\n");
		ret=sigprocmask(SIG_BLOCK,&set,&oldSet);
		if(0==ret)printf("设置信号屏蔽成功！\n");
		else printf("设置信号屏蔽失败！：%m");
	}
	sleep(20);//解除信号屏蔽
	if(1==sigismember(&set,2))
	{
		printf("解除信号屏蔽");
		ret=sigprocmask(SIG_UNBLOCK,&set,&oldSet);
		if(0==ret)printf("解除信号屏蔽成功！\n");
		else printf("解除信号屏蔽失败！：%m\n");
	}
	while(1);
	return 0;
}
~~~





**IPC :Inter Procss Communication**   （同一主机上）

key    int   用来保证唯一性    		fd

A   B   	shm1

C	D	  shm2

shm	msg 	sem	都必须先有一个key

根据fd来创建一个key		ftok

用来查看当前主机上IPC的命令：ipc

ipcs		查看        

ipcrm		用来删除        //ipcrm  -q   0

​	-m		shm		共享内存

​	-q		 msq		消息队列

​	-s		 sem		信号量

## 5.共享内存  shm   share  memory

shm  共享内存编程模型  

- 1.创建key  	ftok

- 2.创建共享内存	shmget

- 3.挂载共享内存	shmat

- 4.卸载共享内存 shmdt

- 5.删除共享内存   shmctl

  

## 6.消息队列msgQueue  message  queue

​      msg消息队列   编程模型

- 1.创建key	ftok
  - 2.创建消息队列	msgget
    - 3.收发消息	msgrcv	msgsnd

![1645441687546](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1645441687546.png)

## 7.旗语（信号量） sem   semaphore

![1645442816304](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1645442816304.png)

![1645443166662](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1645443166662.png)

![1645443189577](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1645443189577.png)

![1645453486583](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1645453486583.png)

- 1.创建key	ftok
  - 2.创建信号量	semget
  - 3.

## 8.网络通信





