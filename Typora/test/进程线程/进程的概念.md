# 进程

## 进程的定义

- 狭义定义：进程就是一段程序的执行过程。
- 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统操作系统中，进程既是基本的分配单元，也是基本的执行单元。

**进程的结构特征：进程由程序（代码段）、数据（数据段）和进程控制块PCB(Process Control Block)（堆栈段）三部分组成；多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。**

## 进程的特性

1. 动态性：进程的是指是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的（可参见进程的狭义定义）。
2. 并发性：任何进程都可以同其他进程一起并发执行
3. 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位（可参见进程的广义定义）；
4. 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的，不可预知的速度向前推进。

## Linux进程结构

Linux进程结构由三部分组成：代码段（程序），数据段（数据），堆栈段（进程控制块）。

进程控制块是进程存在的唯一标识。系统通过PCB的存在而感知进程的存在。

系统通过PCB对进程进行管理和调度。PCB包括创建进程、执行进程、退出进程以及改变进程的优先级等。而进程中的PCB用一个名为task_struct的结构体来表示，定义在include/linux/sched.h中，每当创建一个新进程时，便在内存中申请一个空的task_struct结构，填入所需信息，同时，指向该结构体的指针也被加入到task数组中，所有进程控制块都存在task[]数组中。

### 进程的三种状态

- 就绪状态：进程已获得除处理器外的外需资源，等待分配处理器资源，只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。  例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列，而当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。
- 运行状态：进程占用处理器资源，处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲线程。
- 阻塞状态：由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生前即使把处理机分配给该进程，也无法运行。

### 进程和程序的区别

1. **程序是指令和数据的有序集合**，是一个静态的概念，而进程是程序在处理机上的一次执行过程，它是一个动态的概念。
2. 程序可以作为一种软件资料长期存在，而进程是有一定生命周期的。程序是永久的，进程是暂时的。
3. 进程是由进程控制块，程序段，数据段三部分组成，
4. **进程具有创建其他进程的功能，而程序没有**
5. 同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程，也就是说同一程序可以对应多个进程。
6. 在传统的操作系统中，**程序并不能独立运行，作为资源分配和独立运行的基本单元都是进程。**



## 创建进程

引起创建进程的事件：

1. 用户登录
2. 作业调度
3. 提供服务
4. 应用请求

进程的创建过程

一旦操作系统发现了要求创建新线程的事件后，便调用进程创建原语Creat()按照下述步骤创建一个新进程。

1. 申请空白PCB：为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。

2. 为新进程分配资源。

3. 初始化进程控制块。**PCB的初始化包括：**

   1. **初始化标识信息，将系统分配的标识符和父进程标识符填入到新的PCB中。**
   2. **初始化处理机状态信息，将程序计数器指向程序的入口地址，使栈指针指向栈顶。**
   3. **初始化处理机控制信息，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式的方式提出高优先级的要求。**

   

4. 将新进程插入到就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入到就绪队列中
 ## 进程终止

   引起进程终止的事件

   1. 正常结束
   2. 异常结束
   3. 外界干预

进程的终止过程

如果系统发生了上述要求终止进程的某事件后，OS便调用进程终止原语，按下述过程去终止指定的进程。

1. 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程状态。
2. 若该进程正处于执行状态，应立即终止该进程的执行，**并置调度标志为真，用于指示该进程被终止后应该重新进行调度**。
3. 若该进程还有子孙进程，还应该将其所有子孙进程予以终止，以防它们成为不可控的进程。
4. 将被终止的进程所拥有的全部资源，归还给其父进程，或者归还给系统。
5. 将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。

## 阻塞唤醒

### 一、引起进程阻塞和唤醒的事件

1. 请求系统服务
2. 启动某种操作
3. 新数据尚未到达
4. 无新工作可做

### 二、进程阻塞过程

正在执行的进程，当发现上诉某事件后，由于无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。进入block过程后，由于此时该进程还处于执行状态，所以应先立即停止，把进程控制块中的现行状态由执行改为阻塞，并将PCB插入阻塞队列。**如果系统中设置了因不同事件而阻塞得多个阻塞队列**，则应将本进程插入到具有相同事件得阻塞（等待）队列。**<u>最后，转调度程序进程重新调度，将处理机分配给另一就绪进程，并进行切换，保留被阻塞进程的处理机状态（在PCB中）</u>**，再按新进程的PCB中的处理机状态设置CPU环境。

### 三、进程唤醒过程

当被阻塞的进程所期待的事件出现时，如I/O完成或者其所期待的数据已经到达，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒语句wakeup（），将等待该事件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。

