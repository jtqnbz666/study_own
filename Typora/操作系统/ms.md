inode索引节点，通过ls -i 即可看到每个文件或者文件夹对应的索引号，对于目录(特殊的文件夹)来讲，他存储的内容就是该目录下所有的其他目录和文件的索引号。
索引节点上不包含文件名称信息， 文件名称改变不会对索引节点造成影响。通过索引节点号来找到对应文件。

### 四核八线程

一路就是一个cpu的意思， 多路就是多个cpu的意思， 一个cpu可以有多个核， 每个核都有独立的ALU等资源，计算机的计算核心也是ALU， 虽然平时说4核八线程， 但其实笔记本电脑中只有一个cpu， 这八个线程被称为cpu的超线程技术， 那么我们平时的pthread_create() 出来的线程又是什么呢，比如pthread_create()出来20个， 那么其实就是这八个线程在轮流的切换这20个，而这四个核心又在轮流切换这个八个线程。

多一个核，如果散热不出问题，性能提升100%。而超线程技术是多一个线程，实力提升约30%（同样是理想化的散热）。假设一个核处理能力是100%，8C8T就是800%，4C8T就是520%。这么算4C8T是8C8T的65%。

但是也要注意判别是真四核还是假四核，**抓住核心**：就是ALU才是真正的计算单元，但就像我们平时所说的同步和异步一样，多个进程在执行的时候总有空闲的时刻， 比如其中一个进程中的sockfd是阻塞的，那么调用send就阻塞了，这时候cpu就会被别的进程利用起来，所以是能提高效率的。

为什么上边说的都是进程，因为线程才是调度执行的基本单位，一个进程如果不开多线程，那么就可以把这个进程理解为主线程。



## 进程线程问题



本质区别， 资源分配(进程)， 调度执行(线程)

用户级上下文切换  (虚拟内存的更换)   //主要区别
系统(内核)级上下文切换  (PCB(进程控制块) ，比如更改状态，休眠，运行等等)
硬件上下文切换(寄存器等)

切换问题：
对于进程 ，上述3者都有， 而线程， 只有后两者



并发性问题：
进程低， 线程高， 原理是就是切换问题



地址空间问题：

进程有独立的虚拟地址空间， 线程没有独立的地址空间，但线程有独立的栈。



所属关系：

一个线程属于一个进程， 一个进程可以拥有多个线程。



健壮性：

进程高， 一个崩溃不影响别的进程
线程低， 一个线程异常，可能导致整个进程崩溃



nginx用多进程(**master 进程被设计用来的目的是做 worker 进程的管理的， Nginx 最核心的一个目的是要保持高可用性、高可靠性，生产环境中我们必须保持 Nginx 足够健壮，单进程结构实际上不适用于生产环境，只适合我们做开发调试使用**)， redis用多线程(处理一些业务逻辑，并发性高，共享虚拟地址空间，切换代价低)





## 系统调用

malloc是库函数， 里面用了系统调用，但本身不是系统调用

应用程序->库函数->系统调用->内核

用户态->内核态： 1.系统调用(软中断)，2.中断 3.异常(缺页异常)

触发中断->系统调用号放入eax寄存器->执行中断 int 0x80->切换堆栈，用户态切换内核态(保存现场)-> 运行内核代码-> 恢复运行现场。



执行中断处理： 根据中断号找到中断处理程序->根据系统调用号从系统调用表上找到处理函数并调用。

从中断处理程序返回：iret 返回，由内核态->用户态

系统调用会不会引起进程或者线程切换？

~~~c
不一定， 若是阻塞io就会(且数据未准备好)， 若是非阻塞io就不会.
2.如果从系统态返回用户态时，有优先级更高的进程也有可能发生切换    
~~~





malloc是如何分配内存的：

~~~
brk(堆)， 或者 mmap(文件映射段)  他们都是系统调用
    
   当分配的内存 < 128k,   brk
   反之 mmap
   
brk原理：
brk是将数据段(.data)的最高地址指针_edata往高地址推；
比如先malloc(40k)，再malloc(30k),此时_edata指针在70的位置，此时释放最开始分配的40k，但因为_edata指针只有一个，所以那30k无法释放，相当于是把这一共的70k用作内存池，此时如果再申请40k，就会把那40k直接返回回去，避免了系统调用，同时减少了缺页异常，如果不申请这40k，那么这40k就成为了内存碎片。

先从内存池中看是否由合适大小的块，如果有，就直接分配内存池中的空闲块。
如果内存池中找到了(这里需要明白，如果是在维护的内存池中找到的，说明不是第一次访问这块内存，可能已经有了页表映射关系)，说明页表(MMU)的映射关系可能还在， 能够减少触发缺页异常。

缺点: 频繁malloc 和 free， 容易出现内部内存碎片，因为是内存池管理，放在内存池没用
	
	mmap原理：
>128k， 每次都会发生系统调用，只要没有访问过，就没有映射关系，所以会频繁的发生缺页异常
但mmap分配的内存可以单独释放。

为什么不全部 使用brk 或者 mmap， 因为局部性原理：比如每个进程都是4G虚拟空间，但只有少部分会放到物理内存上，有时候我们只需要小部分内存brk效率更好
   
~~~



free是如何释放内存的，怎么确定释放内存的大小

~~~c
如果是brk系统调用，仍在malloc内存池中，下次可以继续使用
如果是mmap系统调用，free后立刻归还

malloc在分配的时候，前边会加上16个字节， 用来描述分配内存的大小等信息。

free在内部做了左偏移，偏移16个字节即可获取内存大小。
~~~



缺页异常：

~~~
1.若是去写只读的页也会发生缺页异常(fork的情况，也就是写时拷贝)
2.映射关系不存在
	-.本来就没有映射关系，比如程序刚开始运行，第一次去访问都没有映射
    -.中途malloc或者mmap，第一次访问也没有映射关系

若已经没有空闲页，则调用页面置换算法，将一个物理页换出到磁盘(会检查它是否修改过，如果没有修改直接丢弃了就好了)，并将页表项置为无效(直接设置为没有映射关系)，将置换出来的这个物理页框映射到我当前发生缺页中断的这个虚拟页面中，那么我当前的这个缺页中断就设置好了，缺页中断处理完毕，然后就正常执行逻辑操作就可以了。
通过以上分析可以发现，是不会出现虚拟页面不为0， 但在/不在位为 0 的情况的， 因为当一个页面被置换出去后，会马上把在/不在位置设置为0；同样当虚拟页面不为0，也说明在/不在位一定为1。
~~~



页面置换算法

~~~c
最佳页面置换算法
先进先出
最久未使用
时钟页面
最不常用

目标：减少页面切换
~~~



## 访问一个虚拟地址经历的过程

页表的主要项：修改位(是否修改，若修改则为脏数据，需要写会磁盘，反之直接丢掉)，在/不在位， 保护位(读写方式)，访问位(后续页面置换时的重要参数)， 页框号(实际物理页的位置)。 高速缓存位(能用寄存器更快)

CPU先将虚拟地址交由MMU ，它会对照页表来找到具体的页框号(物理页)，若没有对应的映射，则触发缺页异常，那就先访问数据在磁盘上的位置，构建好映射后再访问，如果是要对一个只读的页面进行修改，那么也会触发异常(也就是写时拷贝技术)。

比如是16位寻址空间，每页大小为4k, 则后12位表示4k，前四位表示虚拟页框号，所以页表需要有16个页表项

加速分页过程：
1.TLB块表
2.如果虚拟地址空间很大， 需要多级页表，比如32位的寻址空间， 一个页位4k(也就是10的12次方)，那么就需要10的20次方个页表项，那么页表就会非常大，占用的内存就多了，所以采用了二级页表

## free命令

探讨free命令中的buffer/cache字段：

首先明白设备的最小寻址单位是**扇区**，而操作系统的文件系统的最小寻址单位是**块**。每一个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个块，当一个块被调入内存时，它要存储在一个'缓冲区'中，**每个缓冲区与一个块对应**， 它相当于是磁盘块在内存中的表示

buffer: 也就是buffer cache，中文为 **'缓冲区'**
buffer cache只有块的概念没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟放的是什么格式的文件。

cache:也就是cache page ，中文为**'页高速缓存'**，其实'**缓冲区**'就是特殊的页高速缓存。
页高速缓存缓存的是内存页面，缓存中的页来自对普通文件、**块设备文件**和内存映射文件的读写。

页高速缓存对**块设备文件**的缓存就是我们在前面介绍的 buffer cache



页高速缓存对普通文件的缓存我们可以这样理解：当内核要读一个文件（比如 /etc/hosts）时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块 I/O 操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件（比如 /etc/hosts）。

页高速缓存对块设备文件的缓存就是前面介绍的 buffer cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(**缓冲区最终是由页高速缓存来承载的**)



对于free命令中的free字段，available 字段:
buffer 和 cache 都属于已经被使用的内存。应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，`available = free + buffer + cache`，但实际数据往往有差异